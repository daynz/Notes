[TOC]

# 类与对象

## 数据抽象和封装

类的基本思想是数据抽象和封装。
- 数据抽象：依赖与接口和实现分离的编程技术。
	- 接口：包括用户所能执行的操作。
	- 实现：包括类的成员、负责接口实现的函数体以及定义类所需的各种私有函数。
- 封装：实现了类的接口和实现的分离。封装后的类隐藏了实现细节，类的用户只能使用接口而无法访问实现部分。

##  成员变量

成员变量是类中定义的变量，可以使用各种数据类型，用于存储与类的对象相关的数据。成员变量可称为属性。

### 内置类型

#### 基本内置类型

- 定义：默认不会初始化，初始值是未定义的（未定义行为）。可以给定初始值。
- 初始化：非必须
- 构造：构造时需要初始化，创建时自动分配内存。
- 析构：不需要做任何处理，不需要显式分配或释放内存。

最好在构造函数中初始化成员变量，或在声明时给定初始值。
基本内置类型的成员变量在对象创建时自动分配内存，不需要显式分配或释放内存。

### 指针类型与引用类型

**使用时要注意动态内存管理**

- 定义：默认不会初始化，初始值是未定义的（未定义行为），可能是未知的地址。可能导致悬空指针或内存泄漏。
- 构造：构造时需要初始化，分配内存。也可初始化为`nullptr`
- 析构：必须释放指针成员变量所指向的动态分配的内存，以防止内存泄漏。确保在释放指针指向的内存后，将指针设置为`nullptr`，以避免野指针问题。

### 使用STL库

- **内存管理**：STL容器自动管理它们所包含元素的内存。这意味着当你向容器中添加元素时，容器会负责分配内存来存储这些元素，而当元素不再需要时，容器也会负责释放内存。
- **拷贝和移动语义**：STL容器支持拷贝和移动语义，这意味着容器可以被拷贝或移动，而不是它们的元素被拷贝或移动。这可以提高效率，特别是在处理大型容器时。在你的类中使用STL容器时，你也应该支持拷贝和移动语义。

###  自定义类型

类可以包含自定义类型，这些类型可以是其他类、结构体（struct）、枚举（enum）或者是类型别名（using 或 typedef）。使用自定义类型可以让代码更加模块化、可重用和易于维护。

####  其他类

- **成员对象**：一个类可以拥有另一个类的实例作为其成员，这称为成员对象。
- **聚合**：如果一个类的对象被另一个类的对象所拥有，这种关系称为聚合。聚合是一种特殊的关联，表示整体与部分的关系。
- **组合**：组合是一种比聚合更强的关联，表示类的对象完全拥有另一个类的对象。组合对象的生命周期通常由组合它的类管理。

#### 结构体、枚举、类型别名

TODO

### 初始化

- 直接初始化：在成员变量声明时直接进行初始化
- 构造函数成员初始化列表：对于大多数类类型成员变量，推荐使用构造函数的成员初始化列表来进行初始化。直接在创建对象时初始化成员变量，而不是在构造函数体内赋值。
- 构造函数内初始化：在构造函数中赋值，不推荐。
- 默认成员变量：如果你没有为成员变量提供初始值，它们将被默认初始化。对于基本数据类型，这意味着它们将包含垃圾值（对于内置的POD类型，如int、double等）。对于类类型，将调用默认构造函数（如果存在）。
- 列表初始化：C++11

### const成员变量

在声明`const`成员变量时，通常需要在类的构造函数初始化列表中或声明时进行初始化，因为`const`变量一旦初始化后就不能在类的成员函数中被修改。如果尝试修改`const`成员变量，会导致编译错误。`const`成员变量的值在对象的生命周期内保持不变。
### static成员变量

`static`成员变量在类的内部进行定义和声明时，需要使用`static`关键字进行修饰。在类的外部需要对`static`成员变量进行初始化。

`static`成员变量被存储在类的静态存储区，而不是每个对象的内存空间中。这意味着无论创建多少个类的对象，`static`成员变量只有一份副本。所有的对象都共享同一个`static`成员变量。

`static`成员变量可以在没有创建类的对象的情况下被访问。可以通过类名直接访问`static`成员变量，而不需要通过对象来访问。

`static`成员变量的生命周期与整个程序的运行周期相同。它在程序开始执行时被创建，在程序结束时被销毁。

##  成员函数

成员函数是类中定义的函数，定义了类的行为。

###  基本成员函数

### 构造函数

### 析构函数

### const成员函数

`const`成员函数表明该函数不会修改它所属对象的任何成员变量。`const`成员函数可以访问对象的所有成员变量和其他`const`成员函数，但不能调用非`const`成员函数。

`const`成员函数保证不会改变对象的任何成员变量的值，除非这些成员变量本身被声明为`mutable`（TODO）。

`const`成员函数可以在常量对象上被调用。这意味着如果你有一个常量对象，你只能调用它的`const`成员函数。

`const`成员函数可以返回对象的常量引用，这样可以避免返回值被修改。

### static成员函数

static成员函数不依赖于类的具体对象实例。静态成员函数不能访问类的非静态成员变量，因为这些变量是与特定对象实例相关的。静态成员函数只能访问类的静态成员变量和其他静态成员函数。
静态成员函数可以通过类名直接调用，也可以通过对象实例调用。通常推荐使用类名调用，以强调其静态性质。

### 成员函数重载

成员函数重载是通过在同一个类中定义多个具有相同名称的成员函数来实现的，但这些函数的参数列表必须不同。参数列表不同可以是参数的数量、类型或顺序不同。成员函数重载的主要目的是提供多态性（静态多态性），使得同一个函数名可以用于不同的操作。这使得代码更加清晰和易于维护。

## this

`this`是一个特殊的指针，它在每个非静态成员函数中都有定义。`this`指向调用成员函数的对象的地址。使用`this`指针可以访问对象的成员变量和成员函数。

### this用法

1. **区分成员变量和局部变量**：当成员函数中有一个与成员变量同名的局部变量时，可以使用`this`指针来明确指出你想要访问的是成员变量。
2. **返回对象本身**：在成员函数中，如果你想返回对象本身，可以使用`this`指针。
3. **链式调用**：`this`指针可以用于实现链式调用，即一个函数返回对象的引用，然后可以立即调用另一个函数。
4. **在成员函数中使用`this`**： 在成员函数中，你可以直接使用`this`，而不需要任何前缀。
5. **在静态成员函数中**： 静态成员函数不能访问`this`指针，因为静态成员函数不与任何特定的对象实例关联。

## 类作用域(Scope)

类的作用域是指类成员（包括数据成员和成员函数）的可见性和访问权限。类的作用域规则决定了在类的外部或内部哪些成员是可以访问的。

- **类外访问类的成员**，可以使用作用域解析运算符`::`。
- **成员函数中的作用域**： 在成员函数内部，你可以访问类的其他成员，包括其他成员函数和数据成员。成员函数可以调用其他成员函数，也可以访问类的实例变量。

**成员访问权限**： C++中的类成员可以有三种访问权限：`public`、`protected`和`private`。
- `public`：类的公共成员可以在类的外部被访问。
- `protected`：受保护的成员只能在类的内部以及继承自该类的子类中被访问。
- `private`：私有成员只能在类的内部被访问。

## 友元（Friend）

友元是一种特殊的机制，它允许一个非成员函数或者一个类的成员函数访问另一个类的私有（private）和受保护（protected）成员。友元机制打破了类的封装性，使得某些特定的函数可以访问类的内部数据，这在某些情况下是非常有用的，比如实现某些操作符重载、辅助函数或者与其他类进行紧密协作时。

友元是一种强大的机制，但它也破坏了类的封装性，因此在使用时需要谨慎。过度使用友元可能会导致代码难以维护和理解，因为它模糊了类之间的界限。在设计类时，应该尽可能地使用公共接口来实现所需的功能，只在必要时使用友元。

### 友元函数

友元函数是一个非成员函数，它可以访问类的私有和受保护成员。

### 友元类

友元类是指一个类可以声明另一个类为其友元，这样另一个类的所有成员函数都可以访问该类的私有和受保护成员。

**注意事项**

1. **友元是单向的**：如果类A是类B的友元，并不意味着类B自动成为类A的友元。如果需要双向访问，两个类必须相互声明对方为友元。
2. **友元不继承**：友元关系不具有继承性。如果类B是类A的友元，类C继承自类A，并不意味着类C自动成为类B的友元。
3. **友元与封装**：虽然友元可以访问类的私有和受保护成员，但它们并不是类的成员，因此不能直接访问类的保护成员，除非这些保护成员也是公有的。
4. **友元与多态**：友元函数不能访问类的虚函数表，因此它们不能利用多态性。

## 类类型

