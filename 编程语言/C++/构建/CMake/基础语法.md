# 第3章 基础语法

## CMake 程序

### 类型

- **CMakeLists.txt 文件**
  - 用于组织构建项目源程序的目录结构，与构建过程息息相关。

- **.cmake 文件**
  - 分为脚本程序和模块程序两种类型。

### 目录(CMakeLists.txt)

CMake在构建时，需要处理项目的源程序。处理的入口，就是项目顶层目录下的`CMakeLists.txt`。
在`CMakeLists.txt`中，可能还会通过`add_subdirectory`命令将一些子目录追加到构建目录中。这要求子目录中也有一个`CMakeLists.txt`。
`CMakeLists.txt`构成了源程序逻辑上的目录结构，CMake还会根据这个源文件目录的逻辑结构生成用于构建的目录结构，作为构建对应源程序时的工作目录和二进制输出目录。

### 脚本(script.cmake)

指定`-P`参数运行CMake命令行工具可以执行脚本类型的CMake程序。
这种CMake程序不会配置生成任何构建系统，因此一些与构建相关的CMake命令是不允许出现在脚本中的。

### 模块(module.cmake)

CMake的目录程序和脚本程序均可以通过`include`等命令引用CMake模块程序。
CMake提供了很多预制模块供用户使用，多数与环境检测、搜索使用第三方库有关。
CMake模块是一种主要的代码复用单元。

### 注释

#### 单行注释

```cmake
# 单行注释
```

#### 括号注释

```cmake
#[==[
    注释
]==]
```

括号注释可以加若干个等号，以适应不同的注释需求

## 命令参数

### 类型

#### 括号参数
括号参数用于定义命令的参数，可以是直接的字符串或变量。

#### 非引号参数
非引号参数在CMake中用于指定不需要引号的参数。

### 变量引用

使用`${变量}`语法引用变量。

```cmake
${变量}
```

如果变量未定义，CMake不会报错，而是将其替换为一个空字符串。

用set()命令为变量赋值

```cmake
set(变量 值)
```

### 其他变量类型
缓存变量：$CACHE{缓存变量}
环境变量：$ENV{环境变量}
缓存变量可以通过特定语法或普通变量引用语法引用，而环境变量只能通过特定语法引用。如果存在同名的普通变量和缓存变量，普通变量引用会优先匹配。

### 转义字符

使用转义字符需要指定CMake的最低版本要求。

### 特殊括号参数

使用自定义的特殊括号来包含原始文本。

```cmake
message([==[ 参数 ]==])
```

特殊括号可以包含任意数量的等号，用于保留原始文本，不处理任何特殊字符或变量引用

## 变量

### 变量概述
CMake中的变量是存储数据的基本单元。它们总是文本型，但可以被命令解释为数值、列表等。

### 分类

#### 普通变量
- 具有特定作用域。

#### 缓存变量
- 能够被缓存起来，持久化到`CMakeCache.txt`。
- 每次执行CMake程序时，从缓存文件中读取值。
- 用于避免重复耗时过程，如检测编译器路径。
- 具有全局作用域，主要用于构建过程。

#### 环境变量
- 即操作系统的环境变量，对CMake进程具有全局作用域。

### 作用域

#### 函数作用域
- 函数内定义的变量仅在函数内部或调用的其他函数中可见。

#### 目录作用域
- 目录层级具有独立作用域。
- 子目录程序执行前，父目录作用域中的变量被复制到子目录作用域。
- 子目录可以访问但不能修改父目录的变量。
- 对于CMake脚本程序，目录作用域相当于只有一层。

### 保留标识符
CMake保留以下形式的名称，自定义变量或命令时应避开：
- 以`CMAKE_`开头的名称（不区分大小写）。
- 以`_CMAKE_`开头的名称（不区分大小写）。

### 预定义变量
与系统配置、运行环境、构建行为等相关。

### 定义变量

#### 定义普通变量

```cmake
set(变量名 值)
```

- 变量值由若干参数提供，参数间用分号分隔。
- 省略值参数时，相当于调用`unset`命令。

#### 定义到父级作用域
通过`PARENT-SCOPE`可选参数定义变量到父级作用域：
- 对于目录，定义到父目录作用域。
- 对于函数，定义到函数调用者所在作用域。

#### 定义缓存变量

```cmake
set(<变量> <值>... CACHE <变量类型> <变量描述> [FORCE])
```

定义缓存变量的命令比定义普通变量的命令多了CACHE和FORCE参数,以及一些与变量相关的元信息——类型和描述。因为缓存变量具有全局的作用域,就不需要 PARENT_SCOPE参数了。这里的“值"也可以是由若干参数组成的列表,与定义普通变量并无分别。
缓存变量一般应用于目录程序中,便于对构建过程的一些配置进行持久化。

FORCE可选参数用于强制覆盖缓存变量的值。默认情况下,如果缓存变量已经被定义， CMake会忽略后续对该缓存变量的set赋值命令，除非这个set命令中指定了 FORCE参数。换句话说,仅当set命令定义的缓存变量不存在或命令参数中包含FORCE时, set命令才会真正定义缓存变量为指定的值。

布尔型缓存变量还可以使用option命令定义:

```cmake
option(<变量> <变量描述> [<ON|OFF>])
```

缓存变量除了可以通过在程序中使用set命令和option命令定义外,还可以通过直接修改持久化缓存文件CMakeCache. txt的方式来定义或覆盖其值。另外, CMake命令行工具的-D参数也可以用于定义或覆盖缓存变量的值，而且有以下两种定义形式：

```cmake
-D <变量>：<缓存变量类型>=<值>
-D <变量>=<值>
```

其中,第二种形式省略了类型,书写简单,因此比较常见。CMake会根据程序中set命令中对该缓存变量的定义将其类型信息补全。

当缓存变量是PATH或FILEPATH类型,且通过命令行为定义的变量值是一个相对路径时, set命令会将这个相对路径根据当前目录转换为绝对路径。这样的做法是合理的:如果该缓存变量出现在某些工具的命令行参数中,而这些工具的工作目录并非当前目录,为了避免相对路径带来的歧义,缓存变量中的路径就应该是绝对路径。

另外,在程序之外定义缓存变量的值通常会优先覆盖程序中定义的值(除非程序中指定了FORCE参数)。因此,缓存变量常常作为项目的配置参数,程序中提供预定义值,而用户可以通过命令行参数等方式设置自定义值。这也是为什么CMake还提供了GUI来修改缓存变量。

定义环境变量

```cmake
set(ENV{<环境变量>} [<值>])
```

环境变量具有全局作用域,不支持使用参数列表来定义值,也没有其他元信息,因此定义环境变量的命令形式是最简单的。另外,通过CMake的set命令定义的环境变量只会影响当前的CMake进程,不会影响到父进程或系统的环境变量配置。

命令中的值参数虽然不能是多个参数构成的列表,但仍然是可选的。如果不填写值参数，CMake 则会将对应环境变量的值清空。

CMake的set命令定义的环境变量仅对当前CMake进程有效, CMake子进程将PATH环境变量的值清空并不影响CMake父进程中的PATH环境变量,因此最终的输出仍是path。

## 列表

### 定义列表变量

```cmake
set(a "a;b;c")
set(b a;b;c)
set(c a b c)
```

### 特殊的分号

当分号前面有一个用于转义的反斜杠时,这个分号不会用作分隔符。
另外,如果一个分号前面存在未闭合的方括号时,该分号也不会被当作元素的分隔符。例如, `[;` `[;]` `[[];`中的分号都无法分隔列表元素,而`[[]];`中的分号是元素的分隔符,因为它前面所有的方括号都已经被闭合。

## 控制结构

### if条件分支

```cmake
if(条件)
  命令
endif()

if(条件)
  命令
elseif(条件)
  命令
else()
  命令
endif()


```

### while判断循环

```cmake
while(条件)
  命令
endwhile()
```

### foreach遍历循环

```cmake
foreach(循环变量 循环项的列表)
  命令
endforeach()
```

<循环项的列表>是一个CMake列表,列表中的元素由分号或空白符分隔。这个循环体的循环次数就是由<循环项的列表>中元素的个数决定的,<循环变量>会被依次赋值为当前遍历到的列表元素。因此,在循环体内部的命令中,可以通过对<循环变量> 的变量引用依次访问列表中的每一个元素。

### 区间遍历

```cmake
foreach（<循环变量> RANGE [<起始值>] <终止值> [<步进>]）
```

<循环变量>会先被赋值为<初始值>，然后每一次循环都会给其增加<步进>指定的大小；当<循环变量>的值大于 <终止值>时,循环终止,且本次循环体不会被执行。<起始值>被省略时,默认为0。<步进>被省略时,默认为1。CMake要求<起始值>、<终止值>和<步进>这三个参数都是非负整数，且<终止值>必须大于等于<起始值>。也就是说,在CMake中区间遍历的<循环变量>只能递增。这个要求相对其他编程语言来说较为严格。

### 高级列表遍历

```cmake
foreach(<循环变量〉 IN [LISTS [<列表变量名的列表>]] [ITEMS [<循环项的列表>]])
```

“高级列表遍历”是“简单列表循环”的超集:如果上述循环的参数中省略LISTS部分,仅保留ITEMS部分,那么它与“简单列表遍历”是等价的。即下面两种写法等价:

```cmake
foreach(<循环变量>INITEMS <循环项的列表>)
foreach(<循环变量> <循环项的列表>)
```

因此这里不再赘述ITEMS部分的参数写法和用途。回到LISTS 部分中的<列表变量名的列表>。它是一个变量名称列表,也就是说,它的每一个元素都是一个变量名称,由分号和空白符分隔。每一个对应的变量又被视为列表变量, foreach循环结构会依次遍历这些列表变量中的每一个元素。

### 打包遍历

```cmake
foreach(<循环变量>... IN ZIP_LISTS <列表变量名的列表>)
```

打包遍历中的<列表变量名的列表>也是一个变量名称列表。打包遍历会对每一个列表变量同时进行遍历,并把各个列表当次遍历到的的元素赋值给不同的循环变量。

- 如果只指定了一个`<循环变量>`,那么当前遍历到的每一个列表变量的元素会依次赋值给`<循环变量>-<N>` (其中"N”对应列表变量的次序)
- 如果指定了多个`<循环变量>`,`<循环变量>`的个数应当与<列表变量名的列表>中的元素个数一致；
- 遍历循环次数以最长的列表变量元素个数为准。如果<列表变量名的列表>中某个列表变量的元素个数比其他列表少,则遍历到后面时会将其对应元素的值视为空字符串。

### 跳出和跳过循环

`break()` `continue()`

- break命令会使循环终止，跳出其所在的最内层循环体。在循环体中，break命令之后的命令都不会再被执行,也不会再次进行条件判断或遍历进入后续循环。该命令同时适用于判断循环结构和遍历循环结构。

- continue命令用于“继续”到下次循环,即跳过本次循环的后续命令,直接进入下次循环的开头。当然,如果根据条件或遍历位置判断后不存在下次循环,则循环即结束。与break类似,该命令同样适用于判断循环结构和遍历循环结构。






