# æ•°æ®ç±»å‹ä¸å†…å­˜ç®¡ç†

---

[toc]

## ä¸€ã€åŸºç¡€æ•°æ®ç±»å‹

---

### 1. æ•´å‹ä¸æ‰©å±•

#### (1) æ ‡å‡†æ•´å‹ä¸ç¬¦å·ä¿®é¥°

```cpp
int a = 42;                      // é»˜è®¤ç¬¦å·ç±»å‹ï¼ˆé€šå¸¸4å­—èŠ‚ï¼‰
unsigned int b = 0xFFFFFFFF;     // æ— ç¬¦å·ç±»å‹ï¼ˆå€¼åŸŸ0~4294967295ï¼‰
short c = 32767;                 // è‡³å°‘16ä½ï¼ˆ-32768~32767ï¼‰
long long d = 9'223'372'036'854'775'807LL;  // C++11å•å¼•å·åˆ†éš”ç¬¦
```

**å…³é”®ç‰¹æ€§**ï¼š

- `signed/unsigned`å½±å“äºŒè¿›åˆ¶æœ€é«˜ä½çš„è§£é‡Šæ–¹å¼

- ç±»å‹å¤§å°é¡ºåºï¼š`short â‰¤ int â‰¤ long â‰¤ long long`ï¼ˆå…·ä½“å­—èŠ‚æ•°ç”±ç¼–è¯‘å™¨å®ç°å†³å®šï¼‰

- ç¬¦å·ä¸åŒ¹é…è­¦å‘Šï¼š

  ```cpp
  unsigned int x = 10;
  int y = -5;
  if (y < x) { /* å¯èƒ½äº§ç”Ÿé€»è¾‘é”™è¯¯ï¼š-5ä¼šè¢«è½¬æ¢ä¸ºå¤§æ­£æ•° */ }
  ```

#### (2) å›ºå®šå®½åº¦ç±»å‹ï¼ˆC++11ï¼‰

```cpp
#include <cstdint>
int8_t byte = -128;          // ç²¾ç¡®8ä½æœ‰ç¬¦å·
uint16_t word = 65535;       // ç²¾ç¡®16ä½æ— ç¬¦å·
int_least32_t val = 100000;  // è‡³å°‘32ä½çš„æœ€å°ç±»å‹
int_fast64_t counter = 0;    // ç³»ç»Ÿå¤„ç†æœ€å¿«çš„64ä½ç±»å‹
```

**æ³¨æ„**ï¼š

- å›ºå®šå®½åº¦ç±»å‹éœ€è¦å¹³å°æ”¯æŒï¼ˆå¦‚`int8_t`å®é™…æ˜¯`signed char`çš„åˆ«åï¼‰

- ä½¿ç”¨å‰æ£€æŸ¥å®å®šä¹‰ï¼š

  ```cpp
  static_assert(sizeof(int32_t) == 4, "Platform not support 32-bit int");
  ```

#### (3) å­—é¢é‡åç¼€

```cpp
auto a = 42;     // int
auto b = 42U;    // unsigned int
auto c = 42L;    // long
auto d = 42ULL;  // unsigned long long
auto e = 0b1010; // C++14äºŒè¿›åˆ¶å­—é¢é‡
```

**ç±»å‹æ¨å¯¼è§„åˆ™**ï¼š

- æ— åç¼€ï¼šé€‰æ‹©`int`â†’`long`â†’`long long`ä¸­ç¬¬ä¸€ä¸ªèƒ½å®¹çº³å€¼çš„ç±»å‹
- æ··åˆç¬¦å·è¿ç®—æ—¶ï¼Œå°ç±»å‹è‡ªåŠ¨æå‡ä¸ºè¾ƒå¤§ç±»å‹

---

### 2. æµ®ç‚¹å‹

#### (1) ç²¾åº¦ä¸èŒƒå›´

```cpp
float f = 3.14159f;          // é€šå¸¸4å­—èŠ‚ï¼ˆçº¦7ä½æœ‰æ•ˆæ•°å­—ï¼‰
double d = 2.718281828459045;// é€šå¸¸8å­—èŠ‚ï¼ˆçº¦15ä½æœ‰æ•ˆæ•°å­—ï¼‰
long double ld = 1.18973e+4932L;  // æ‰©å±•ç²¾åº¦ï¼ˆx86é€šå¸¸80ä½ï¼‰

// ç§‘å­¦è®¡æ•°æ³•
double avogadro = 6.02214076e23;
```

#### (2) ç‰¹æ®Šå€¼å¤„ç†

```cpp
#include <cmath>
double nan = std::nan("");       // ç”ŸæˆNaN
double inf = std::numeric_limits<double>::infinity();
if (std::isnan(nan)) {
    std::cout << "Not a Number detected\n";
}
if (std::isinf(inf)) {
    std::cout << "Infinity detected\n";
}
```

**æ³¨æ„**ï¼š

- ç›´æ¥æ¯”è¾ƒ`NaN`ä¼šå¤±è´¥ï¼š`if (nan == nan)` æ°¸è¿œä¸º`false`
- è¿ç®—è§„åˆ™ï¼š
  - $æ­£æ— ç©· + æ­£æ— ç©· = æ­£æ— ç©·$
  - $æœ‰é™æ•° / æ— ç©· = 0$
  - $0 * æ— ç©· = NaN$

---

### 3. å­—ç¬¦ä¸å¸ƒå°”

#### (1) å­—ç¬¦ç±»å‹

```cpp
char c = 'A';                   // ä¼ ç»Ÿå­—ç¬¦ï¼ˆå®ç°å®šä¹‰ç¬¦å·æ€§ï¼‰
char16_t uc = u'å¥½';            // UTF-16å­—ç¬¦ï¼ˆC++11ï¼‰
char32_t Uc = U'ğˆ';             // UTF-32å­—ç¬¦ï¼ˆC++11ï¼‰
char8_t utf8 = u8'?';           // UTF-8å­—ç¬¦ï¼ˆC++20ï¼‰
const char* str = "Hello";
const char8_t* utf8_str = u8"ä¸­æ–‡";
```

#### (2) å¸ƒå°”ç±»å‹

```cpp
bool success = true;        // 1å­—èŠ‚å­˜å‚¨ï¼ˆé0å³1ï¼‰
int* ptr = nullptr;
if (ptr) { /* ä¸ä¼šæ‰§è¡Œ */ } // ç©ºæŒ‡é’ˆè½¬æ¢ä¸ºfalse

// å¸ƒå°”ä»£æ•°è¿ç®—
bool a = true, b = false;
bool c = a && (b || !a);    // c = false
```

**åº•å±‚å®ç°**ï¼š

- `sizeof(bool)`å§‹ç»ˆä¸º1ï¼Œä½†ä½åŸŸå¯å‹ç¼©ï¼š

  ```cpp
  struct Packed {
      bool b1:1;
      bool b2:1;  // æ€»å…±å ç”¨1å­—èŠ‚
  };
  ```

---

### 4. ç‰¹æ®Šç±»å‹

#### (1) voidç±»å‹

```cpp
// å‡½æ•°æ— è¿”å›å€¼
void log_message(const std::string& msg) {
    std::cout << msg << std::endl;
}

// æ³›å‹æŒ‡é’ˆ
void* data = malloc(1024);
int* int_ptr = static_cast<int*>(data);
```

#### (2) nullptr_t

```cpp
void foo(int) { /* å¤„ç†æ•´å‹ */ }
void foo(int*) { /* å¤„ç†æŒ‡é’ˆ */ }

foo(0);        // è°ƒç”¨intç‰ˆæœ¬
foo(nullptr);  // æ˜ç¡®è°ƒç”¨æŒ‡é’ˆç‰ˆæœ¬

// ç±»å‹æ£€æŸ¥
static_assert(std::is_same_v<decltype(nullptr), std::nullptr_t>);
```

**ä¼˜åŠ¿**ï¼š

- é¿å…å®NULLçš„äºŒä¹‰æ€§ï¼ˆä¼ ç»ŸNULLå¯èƒ½æ˜¯0æˆ–(void*)0ï¼‰

- æ”¯æŒæ¨¡æ¿ç±»å‹æ¨å¯¼ï¼š

  ```cpp
  template<typename T>
  void bar(T ptr) {
      if constexpr (std::is_same_v<T, std::nullptr_t>) {
          // ä¸“é—¨å¤„ç†ç©ºæŒ‡é’ˆ
      }
  }
  ```

---

## å…³é”®æ¦‚å¿µæ€»ç»“è¡¨

| ç±»å‹ç±»åˆ«     | å…¸å‹ç±»å‹         | å¤§å°ï¼ˆå…¸å‹å€¼ï¼‰ | ç‰¹æ€§è¯´æ˜                |
| ------------ | ---------------- | -------------- | ----------------------- |
| æ ‡å‡†æ•´å‹     | `int`            | 4å­—èŠ‚          | å¹³å°ç›¸å…³ï¼Œæœ€å¸¸ç”¨        |
| å›ºå®šå®½åº¦æ•´å‹ | `int32_t`        | 4å­—èŠ‚          | ç²¾ç¡®ä½å®½ï¼Œè·¨å¹³å°ç¨³å®š    |
| æµ®ç‚¹å‹       | `double`         | 8å­—èŠ‚          | é»˜è®¤æµ®ç‚¹è¿ç®—ç±»å‹        |
| Unicodeå­—ç¬¦  | `char16_t`       | 2å­—èŠ‚          | UTF-16ç¼–ç               |
| å¸ƒå°”ç±»å‹     | `bool`           | 1å­—èŠ‚          | å€¼åªèƒ½æ˜¯0æˆ–1            |
| ç©ºç±»å‹       | `void`           | N/A            | ç”¨äºæŒ‡é’ˆæ³›å‹/å‡½æ•°è¿”å›å€¼ |
| ç©ºæŒ‡é’ˆç±»å‹   | `std::nullptr_t` | å¹³å°ç›¸å…³       | ç±»å‹å®‰å…¨çš„ç©ºæŒ‡é’ˆè¡¨ç¤º    |

---

**æœ€ä½³å®è·µ**ï¼š

1. ä¼˜å…ˆä½¿ç”¨`int`è¿›è¡Œå¸¸è§„æ•´æ•°è¿ç®—

2. éœ€è¦ç²¾ç¡®ä½å®½æ—¶ä½¿ç”¨`<cstdint>`ç±»å‹

3. æµ®ç‚¹æ¯”è¾ƒéœ€è€ƒè™‘ç²¾åº¦å®¹å·®ï¼š

   ```cpp
   bool is_equal(double a, double b) {
       return std::abs(a - b) < 1e-9;
   }
   ```

4. é¿å…ä½¿ç”¨`void*`ï¼Œä¼˜å…ˆä½¿ç”¨æ¨¡æ¿æˆ–ç»§æ‰¿å®ç°æ³›å‹

5. å§‹ç»ˆç”¨`nullptr`æ›¿ä»£NULLæˆ–0è¡¨ç¤ºç©ºæŒ‡é’ˆ

# å¤åˆæ•°æ®ç±»å‹

---

## ä¸€ã€æ•°ç»„ä¸å®¹å™¨

---

### 1. é™æ€æ•°ç»„ä¸å¤šç»´æ•°ç»„

```cpp
// æ ˆå†…å­˜é™æ€æ•°ç»„
int arr[5] = {1, 2, 3};  // æœªåˆå§‹åŒ–å…ƒç´ ä¸º0
char str[] = "Hello";     // è‡ªåŠ¨æ¨å¯¼å¤§å°ä¸º6ï¼ˆåŒ…å«'\0'ï¼‰

// å¤šç»´æ•°ç»„ï¼ˆè¡Œä¼˜å…ˆå­˜å‚¨ï¼‰
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
std::cout << matrix[1][2] << "\n";  // è¾“å‡º6
```

**å†…å­˜ç‰¹æ€§**ï¼š

- è¿ç»­å†…å­˜å¸ƒå±€ï¼ˆè¡Œä¼˜å…ˆï¼‰
- å¤§å°ç¼–è¯‘æœŸç¡®å®šï¼Œä¸å¯åŠ¨æ€æ‰©å±•
- è‡ªåŠ¨å˜é‡ç¦»å¼€ä½œç”¨åŸŸåè‡ªåŠ¨é‡Šæ”¾

---

### 2. åŠ¨æ€æ•°ç»„ï¼ˆstd::vectorï¼‰

```cpp
#include <vector>
std::vector<int> vec;
vec.reserve(10);       // é¢„åˆ†é…å®¹é‡ï¼ˆä¸åˆå§‹åŒ–ï¼‰
vec.push_back(42);     // è¿½åŠ å…ƒç´ ï¼ˆå¯èƒ½è§¦å‘æ‰©å®¹ï¼‰\
// åˆå§‹åŒ–æ–¹å¼
std::vector<double> temps{36.5, 37.0, 38.2};
std::vector<std::string> names(5, "Unknown");  // 5ä¸ª"Unknown"
// æ‰©å®¹æœºåˆ¶ç¤ºä¾‹
std::vector<int> v;
for (int i=0; i<100; ++i) {
    v.push_back(i);
    std::cout << "Size: " << v.size() 
              << ", Capacity: " << v.capacity() << "\n";
}
```

**å…³é”®æœºåˆ¶**ï¼š

- æ‰©å®¹ç­–ç•¥ï¼šé€šå¸¸æŒ‰1.5æˆ–2å€å¢é•¿ï¼ˆå®ç°ä¾èµ–ï¼‰
- å†…å­˜è¿ç»­æ€§ä¿è¯ï¼ˆå¯é€šè¿‡`data()`è·å–åŸå§‹æŒ‡é’ˆï¼‰
- ç§»åŠ¨è¯­ä¹‰ä¼˜åŒ–ï¼ˆ`std::move`è½¬ç§»å…ƒç´ æ‰€æœ‰æƒï¼‰

---

### 3. Cé£æ ¼å­—ç¬¦ä¸²å®‰å…¨éšæ‚£

```cpp
char buffer[10];
strcpy(buffer, "1234567890");  // ç¼“å†²åŒºæº¢å‡ºï¼ç¼ºå°‘ç»ˆæ­¢ç¬¦ç©ºé—´

// å®‰å…¨æ›¿ä»£æ–¹æ¡ˆ
std::string safe_str = "Safe string";
std::strncpy(buffer, safe_str.c_str(), sizeof(buffer)-1);
buffer[sizeof(buffer)-1] = '\0';  // å¼ºåˆ¶ç»ˆæ­¢
```

**å¸¸è§é£é™©**ï¼š

- ç¼“å†²åŒºæº¢å‡ºæ¼æ´ï¼ˆå¯è¢«åˆ©ç”¨æ‰§è¡Œä»»æ„ä»£ç ï¼‰
- æœªæ­£ç¡®ç»ˆæ­¢å­—ç¬¦ä¸²å¯¼è‡´å†…å­˜è¶Šç•Œè®¿é—®
- æ¨èä½¿ç”¨`std::string`æ›¿ä»£åŸå§‹å­—ç¬¦æ•°ç»„

---

## äºŒã€è‡ªå®šä¹‰ç±»å‹

---

### 1. ç»“æ„ä½“ä¸å†…å­˜å¯¹é½

```cpp
struct Data {
    char c;      // 1å­—èŠ‚
    int i;       // 4å­—èŠ‚ï¼ˆé€šå¸¸éœ€è¦4å¯¹é½ï¼‰
    double d;    // 8å­—èŠ‚
};  // sizeof(Data) = 1 + 3ï¼ˆå¡«å……ï¼‰ + 4 + 8 = 16ï¼ˆå‡è®¾8å­—èŠ‚å¯¹é½ï¼‰

// æ‰‹åŠ¨å¯¹é½æ§åˆ¶
struct alignas(16) AlignedData {
    float x, y, z;
};  // sizeof(AlignedData) = 16
```

**å¯¹é½è§„åˆ™**ï¼š

- æˆå‘˜åç§»åœ°å€å¿…é¡»æ˜¯å…¶ç±»å‹å¤§å°çš„æ•´æ•°å€
- `sizeof`åŒ…å«å¡«å……å­—èŠ‚
- ä½¿ç”¨`#pragma pack(n)`å¯ä¿®æ”¹å¯¹é½æ–¹å¼ï¼ˆè°¨æ…ä½¿ç”¨ï¼‰

---

### 2. è”åˆä½“ï¼ˆUnionï¼‰

```cpp
union Variant {
    int i;
    double d;
    char str[20];
};

Variant v;
v.i = 42;  // æ­¤æ—¶å…¶ä»–æˆå‘˜çš„å€¼æœªå®šä¹‰

// C++17å¸¦æ ‡ç­¾è”åˆ
struct SafeVariant {
    enum { INT, DOUBLE, STR } tag;
    union {
        int i;
        double d;
        char str[20];
    };
};
```

**åº”ç”¨åœºæ™¯**ï¼š

- èŠ‚çœå†…å­˜ï¼ˆåŒä¸€æ—¶åˆ»åªä½¿ç”¨ä¸€ä¸ªæˆå‘˜ï¼‰
- ç±»å‹åŒå…³ï¼ˆéœ€æ³¨æ„ä¸¥æ ¼åˆ«åè§„åˆ™é™åˆ¶ï¼‰
- ç½‘ç»œåè®®è§£æï¼ˆç›´æ¥æ“ä½œäºŒè¿›åˆ¶æ•°æ®ï¼‰

---

### 3. æšä¸¾ç±»ï¼ˆEnum Classï¼‰

```cpp
enum class Color : uint8_t { Red=1, Green=2, Blue=3 };  // æŒ‡å®šåº•å±‚ç±»å‹
Color c = Color::Red;

// ç±»å‹å®‰å…¨æ¯”è¾ƒ
if (c == Color::Red) { /* æ­£ç¡® */ }
// if (c == 1) { /* é”™è¯¯ï¼šæ— æ³•éšå¼è½¬æ¢ */ }

// æ˜¾å¼è½¬æ¢
int value = static_cast<int>(c);
```

**ä¼˜åŠ¿**ï¼š

- å¼ºä½œç”¨åŸŸï¼ˆå¿…é¡»é€šè¿‡æšä¸¾åè®¿é—®ï¼‰
- ç¦æ­¢éšå¼ç±»å‹è½¬æ¢
- å¯æŒ‡å®šåº•å±‚å­˜å‚¨ç±»å‹ä¼˜åŒ–å†…å­˜

---

## ä¸‰ã€æŒ‡é’ˆä¸å¼•ç”¨

---

### 1. åŸå§‹æŒ‡é’ˆé™·é˜±

```cpp
int* ptr = new int(10);   // åˆ†é…å†…å­˜
delete ptr;               // æ­£ç¡®é‡Šæ”¾
ptr = nullptr;            // é¿å…æ‚¬å‚æŒ‡é’ˆ

// å¸¸è§é”™è¯¯ç¤ºä¾‹
int* dangling = new int(5);
delete dangling;          // é‡Šæ”¾å†…å­˜
*dangling = 10;           // æ‚¬å‚æŒ‡é’ˆè®¿é—®ï¼ˆæœªå®šä¹‰è¡Œä¸ºï¼‰

int arr[5];
int* out = &arr[5];       // è¶Šç•ŒæŒ‡é’ˆï¼ˆåˆæ³•åœ°å€ä½†ä¸å¯è§£å¼•ç”¨ï¼‰
```

**é˜²èŒƒæªæ–½**ï¼š

- åˆå§‹åŒ–æ—¶è®¾ä¸º`nullptr`
- ä½¿ç”¨RAIIåŒ…è£…å™¨ï¼ˆæ™ºèƒ½æŒ‡é’ˆï¼‰
- éµå¾ªå•ä¸€æ‰€æœ‰æƒåŸåˆ™

---

### 2. å¼•ç”¨æœ¬è´¨

```cpp
int x = 10;
int& ref = x;     // å¼•ç”¨å¿…é¡»åˆå§‹åŒ–
ref = 20;         // ä¿®æ”¹xçš„å€¼

// ç¼–è¯‘åç­‰ä»·äºæŒ‡é’ˆæ“ä½œï¼ˆä½†è¯­æ³•æ›´å®‰å…¨ï¼‰
int* const ptr = &x;
*ptr = 20;

// å‡½æ•°å‚æ•°ç¤ºä¾‹
void swap(int& a, int& b) {
    int tmp = a;
    a = b;
    b = tmp;
}
```

**å…³é”®ç‰¹æ€§**ï¼š

- å¿…é¡»ç»‘å®šæœ‰æ•ˆå¯¹è±¡ï¼ˆæ— ç©ºå¼•ç”¨ï¼‰
- ä¸èƒ½é‡æ–°ç»‘å®šï¼ˆå§‹ç»ˆæŒ‡å‘åˆå§‹å¯¹è±¡ï¼‰
- è‡ªåŠ¨è§£å¼•ç”¨ï¼Œæ— éœ€`*`æ“ä½œç¬¦

---

### 3. æ€§èƒ½å¯¹æ¯”ï¼ˆä¼ å‚åœºæ™¯ï¼‰

```cpp
struct BigData { int buffer[1024]; };

// ä¼ å€¼ï¼šæ‹·è´æ•´ä¸ªç»“æ„ä½“ï¼ˆé«˜å¼€é”€ï¼‰
void process_value(BigData data);

// ä¼ constå¼•ç”¨ï¼šé›¶æ‹·è´ï¼Œåªè¯»è®¿é—®
void process_cref(const BigData& data);

// ä¼ å³å€¼å¼•ç”¨ï¼šæ”¯æŒç§»åŠ¨è¯­ä¹‰
void process_rref(BigData&& data);
```

**æ€§èƒ½å‡†åˆ™**ï¼š

- å°å¯¹è±¡ï¼ˆ<=å¯„å­˜å™¨å¤§å°ï¼‰ä¼˜å…ˆä¼ å€¼
- å¤§å¯¹è±¡ä½¿ç”¨`const T&`é¿å…æ‹·è´
- éœ€è¦ä¿®æ”¹åŸå§‹å¯¹è±¡æ—¶ä½¿ç”¨`T&`
- æ”¯æŒç§»åŠ¨è¯­ä¹‰çš„åœºæ™¯ä½¿ç”¨`T&&`

---

## å¤åˆæ•°æ®ç±»å‹å¯¹æ¯”è¡¨

| ç±»å‹        | å­˜å‚¨ä½ç½®  | å¤§å°å¯å˜ | å†…å­˜ç®¡ç† | å…¸å‹ç”¨é€”             |
| ----------- | --------- | -------- | -------- | -------------------- |
| é™æ€æ•°ç»„    | æ ˆ/é™æ€åŒº | å¦       | è‡ªåŠ¨     | å›ºå®šå¤§å°æ•°æ®é›†åˆ     |
| std::vector | å †        | æ˜¯       | è‡ªåŠ¨     | åŠ¨æ€æ‰©å®¹æ•°æ®é›†       |
| ç»“æ„ä½“      | è¿ç»­å†…å­˜  | ç¼–è¯‘æœŸå®š | æ‰‹åŠ¨     | æ•°æ®èšåˆ             |
| è”åˆä½“      | å…±äº«å†…å­˜  | å›ºå®š     | æ‰‹åŠ¨     | å†…å­˜å¤ç”¨åœºæ™¯         |
| åŸå§‹æŒ‡é’ˆ    | å †/æ ˆ     | -        | æ‰‹åŠ¨     | ä½çº§å†…å­˜æ“ä½œ         |
| å¼•ç”¨        | åˆ«å      | -        | è‡ªåŠ¨     | å‡½æ•°å‚æ•°ã€è¿”å›å€¼ä¼˜åŒ– |

---

**æœ€ä½³å®è·µ**ï¼š

1. ä¼˜å…ˆä½¿ç”¨`std::vector`æ›¿ä»£åŸå§‹æ•°ç»„
2. ç»“æ„ä½“æˆå‘˜æŒ‰å¯¹é½éœ€æ±‚æ’åºï¼ˆä»å¤§åˆ°å°ï¼‰
3. ä½¿ç”¨`enum class`æ›¿ä»£ä¼ ç»Ÿæšä¸¾
4. é¿å…è£¸æŒ‡é’ˆï¼Œä½¿ç”¨`std::unique_ptr`/`std::shared_ptr`
5. å¤§å¯¹è±¡ä¼ å‚ä½¿ç”¨`const T&`æˆ–ç§»åŠ¨è¯­ä¹‰
6. å¯¹è”åˆä½“è®¿é—®æ·»åŠ ç±»å‹æ ‡ç­¾ä¿è¯å®‰å…¨æ€§

```cpp
// ç»¼åˆç¤ºä¾‹ï¼šå®‰å…¨ç±»å‹è½¬æ¢
template<typename T>
T safe_deref(void* ptr) {
    if (!ptr) throw std::invalid_argument("Null pointer");
    return *static_cast<T*>(ptr);
}
```

# åŠ¨æ€å†…å­˜ç®¡ç†

---

## ä¸€ã€æ‰‹åŠ¨å†…å­˜ç®¡ç†

---

### 1. `new`/`delete`åº•å±‚æœºåˆ¶

```cpp
// å…¨å±€operator newé‡è½½ç¤ºä¾‹
void* operator new(size_t size) {
    std::cout << "Allocating " << size << " bytes\n";
    return malloc(size);
}

// è‡ªå®šä¹‰ç±»å†…å­˜ç®¡ç†
class Widget {
public:
    Widget() { /* å¯èƒ½æŠ›å‡ºå¼‚å¸¸ */ }
    ~Widget() { /* èµ„æºé‡Šæ”¾ */ }
};

try {
    Widget* obj = new Widget;  // 1. è°ƒç”¨operator newåˆ†é…å†…å­˜
                                // 2. è°ƒç”¨æ„é€ å‡½æ•°ï¼ˆè‹¥å¤±è´¥ï¼Œè‡ªåŠ¨é‡Šæ”¾å†…å­˜ï¼‰
} catch (const std::bad_alloc& e) {
    std::cerr << "Allocation failed: " << e.what() << "\n";
}
```

**å¼‚å¸¸å®‰å…¨æœºåˆ¶**ï¼š

- æ„é€ å‡½æ•°æŠ›å‡ºå¼‚å¸¸æ—¶ï¼Œå·²åˆ†é…çš„å†…å­˜ä¼šè¢«è‡ªåŠ¨å›æ”¶

- `delete`æ“ä½œè‡ªåŠ¨è°ƒç”¨ææ„å‡½æ•°å¹¶é‡Šæ”¾å†…å­˜

- **é”™è¯¯ç¤ºä¾‹**ï¼š

  ```cpp
  int* arr = new int[10];
  delete arr;  // é”™è¯¯ï¼åº”ä½¿ç”¨delete[]
  ```

---

### 2. å¼‚å¸¸å®‰å…¨æœ€ä½³å®è·µ

```cpp
// RAIIåŒ…è£…å™¨ç¤ºä¾‹
class FileHandler {
    FILE* file;
public:
    explicit FileHandler(const char* filename) : file(fopen(filename, "r")) {
        if (!file) throw std::runtime_error("File open failed");
    }
    ~FileHandler() { if(file) fclose(file); }
    // ç¦ç”¨æ‹·è´ï¼ˆé˜²æ­¢åŒé‡é‡Šæ”¾ï¼‰
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
};

void process_file() {
    FileHandler f("data.bin");  // å¼‚å¸¸å®‰å…¨
    // ä½¿ç”¨æ–‡ä»¶èµ„æº...
}
```

---

## äºŒã€æ™ºèƒ½æŒ‡é’ˆ

---

### 1. `unique_ptr`ï¼ˆç‹¬å æ‰€æœ‰æƒï¼‰

```cpp
#include <memory>

// åˆ›å»ºç‹¬å æŒ‡é’ˆ
auto ptr = std::make_unique<int>(42);  // C++14æ¨è
std::unique_ptr<int[]> arr(new int[5]{1,2,3,4,5});

// æ‰€æœ‰æƒè½¬ç§»
auto new_owner = std::move(ptr);  // ptrå˜ä¸ºnullptr

// è‡ªå®šä¹‰åˆ é™¤å™¨
auto file_deleter = [](FILE* f) { if(f) fclose(f); };
std::unique_ptr<FILE, decltype(file_deleter)> 
    file_ptr(fopen("data.txt", "r"), file_deleter);
```

**ç‰¹æ€§**ï¼š

- é›¶è¿è¡Œæ—¶å¼€é”€ï¼ˆä¸è£¸æŒ‡é’ˆç›¸åŒå¤§å°ï¼‰
- ç¦æ­¢æ‹·è´ï¼Œåªå…è®¸ç§»åŠ¨
- é€‚ç”¨äºå·¥å‚æ¨¡å¼è¿”å›å¯¹è±¡

---

### 2. `shared_ptr`ï¼ˆå…±äº«æ‰€æœ‰æƒï¼‰

```cpp
struct Node {
    std::shared_ptr<Node> next;
    // std::shared_ptr<Node> prev;  // å¯¼è‡´å¾ªç¯å¼•ç”¨
    std::weak_ptr<Node> prev;       // æ­£ç¡®æ–¹æ¡ˆ
};

auto node1 = std::make_shared<Node>();
auto node2 = std::make_shared<Node>();

node1->next = node2;
node2->prev = node1;  // ä½¿ç”¨weak_ptræ‰“ç ´å¾ªç¯

// æ§åˆ¶å—ç»“æ„
// [å¼•ç”¨è®¡æ•° | å¼±å¼•ç”¨è®¡æ•° | åˆ é™¤å™¨ | åˆ†é…å™¨ | å¯¹è±¡]
```

**å†…å­˜ä¼˜åŒ–**ï¼š

- `make_shared`å•æ¬¡åˆ†é…å¯¹è±¡å’Œæ§åˆ¶å—
- `shared_ptr`å¤§å°æ˜¯è£¸æŒ‡é’ˆçš„ä¸¤å€ï¼ˆå«æ§åˆ¶å—æŒ‡é’ˆï¼‰

---

### 3. `weak_ptr`ä¸`make_*`å‡½æ•°

```cpp
auto shared = std::make_shared<std::string>("Modern C++");
std::weak_ptr<std::string> observer = shared;

if (auto locked = observer.lock()) {  // å®‰å…¨è®¿é—®
    std::cout << *locked << "\n";
}

// æ€§èƒ½å¯¹æ¯”
auto p1 = std::shared_ptr<int>(new int(10));  // ä¸¤æ¬¡å†…å­˜åˆ†é…
auto p2 = std::make_shared<int>(20);          // å•æ¬¡å†…å­˜åˆ†é…
```

---

## ä¸‰ã€å†…å­˜æ£€æµ‹å·¥å…·

---

### 1. `Valgrind`åŸºç¡€ä½¿ç”¨

```bash
# æ£€æµ‹å†…å­˜æ³„æ¼
valgrind --leak-check=full ./your_program

# å…¸å‹è¾“å‡º
==12345== 40 bytes in 1 blocks are definitely lost
==12345==    at 0x483777F: operator new[](unsigned long)
==12345==    by 0x1091FE: main (example.cpp:10)
```

**æ£€æµ‹èƒ½åŠ›**ï¼š

- æœªåˆå§‹åŒ–å†…å­˜è®¿é—®
- å†…å­˜è¶Šç•Œ
- åŒé‡é‡Šæ”¾
- æœªé…å¯¹åˆ†é…/é‡Šæ”¾ï¼ˆnew/delete[]ä¸åŒ¹é…ï¼‰

---

### 2. `AddressSanitizerï¼ˆASanï¼‰`

```cpp
// ç¼–è¯‘å‘½ä»¤
g++ -fsanitize=address -g -O1 -o test test.cpp

// å †æº¢å‡ºæ£€æµ‹ç¤ºä¾‹
void heap_buffer_overflow() {
    int* arr = new int[10];
    arr[10] = 0;  // é”™è¯¯å†™å…¥
    delete[] arr;
}
```

**å®æ—¶æ£€æµ‹ç‰¹æ€§**ï¼š

- ç«‹å³å´©æºƒå¹¶å®šä½é”™è¯¯ä½ç½®
- æ”¯æŒæ£€æµ‹æ ˆ/å…¨å±€å˜é‡æº¢å‡º
- å†…å­˜æ¶ˆè€—æ¯”Valgrindå°‘

---

## å†…å­˜ç®¡ç†æ–¹æ¡ˆå¯¹æ¯”

| ç®¡ç†æ–¹å¼         | ä¼˜ç‚¹               | ç¼ºç‚¹                   | é€‚ç”¨åœºæ™¯           |
| ---------------- | ------------------ | ---------------------- | ------------------ |
| æ‰‹åŠ¨`new/delete` | å®Œå…¨æ§åˆ¶           | æ˜“å‡ºé”™ï¼Œéœ€ä¸¥æ ¼é…å¯¹     | åº•å±‚ä¼˜åŒ–ï¼Œç‰¹æ®Šéœ€æ±‚ |
| `unique_ptr`     | é›¶å¼€é”€ï¼Œç‹¬å æ‰€æœ‰æƒ | ä¸å¯å…±äº«               | å•ä¸€æ‰€æœ‰è€…èµ„æºç®¡ç† |
| `shared_ptr`     | è‡ªåŠ¨ç”Ÿå‘½å‘¨æœŸç®¡ç†   | å¾ªç¯å¼•ç”¨é£é™©ï¼Œæ€§èƒ½å¼€é”€ | å…±äº«æ‰€æœ‰æƒåœºæ™¯     |
| å†…å­˜æ±            | å‡å°‘ç¢ç‰‡ï¼Œå¿«é€Ÿåˆ†é… | å®ç°å¤æ‚               | é«˜é¢‘å°å¯¹è±¡åˆ†é…     |

---

## æœ€ä½³å®è·µ

1. **ä¼˜å…ˆä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ**ï¼š

   ```cpp
   auto data = std::make_shared<DataSet>();  // æ›¿ä»£new DataSet
   ```

2. **é¿å…è£¸æŒ‡é’ˆæ‰€æœ‰æƒä¼ é€’**ï¼š

   ```cpp
   void process(std::unique_ptr<Data> ptr);  // æ˜ç¡®æ‰€æœ‰æƒè½¬ç§»
   ```

3. **å¼‚å¸¸å®‰å…¨è®¾è®¡**ï¼š

   ```cpp
   try {
       auto res = std::make_unique<Resource>();
       res->initialize();  // å¯èƒ½æŠ›å‡ºå¼‚å¸¸
   } catch (...) {
       // unique_ptrè‡ªåŠ¨é‡Šæ”¾å†…å­˜
   }
   ```

4. **å†…å­˜æ£€æµ‹é›†æˆ**ï¼š

   ```cmake
   # CMakeä¸­å…¨å±€å¯ç”¨ASan
   add_compile_options(-fsanitize=address)
   add_link_options(-fsanitize=address)
   ```

5. **æ€§èƒ½å…³é”®ä»£ç ä¼˜åŒ–**ï¼š

   ```cpp
   // é¢„åˆ†é…å¯¹è±¡æ± 
   static std::vector<std::unique_ptr<Object>> object_pool;
   ```

---

```cpp
// ç»¼åˆç¤ºä¾‹ï¼šå®‰å…¨å†…å­˜ç®¡ç†
class DatabaseConnection {
    std::unique_ptr<Connection> conn;
public:
    DatabaseConnection() : conn(create_connection()) {}
    
    void query(const std::string& sql) {
        if (!conn) throw std::runtime_error("No active connection");
        // æ‰§è¡ŒæŸ¥è¯¢...
    }
    
    ~DatabaseConnection() {
        if (conn) close_connection(conn.release());
    }
};
```

# ç±»å‹ç³»ç»Ÿä¸è½¬æ¢

---

## ä¸€ã€ç±»å‹è½¬æ¢

---

### 1. éšå¼è½¬æ¢çš„é£é™©

```cpp
// çª„åŒ–è½¬æ¢ç¤ºä¾‹
double d = 3.1415926;
int i = d;  // éšå¼è½¬æ¢ï¼Œä¸¢å¤±ç²¾åº¦ï¼ˆç¼–è¯‘å™¨å¯èƒ½äº§ç”Ÿè­¦å‘Šï¼‰
char c = 300; // æº¢å‡ºï¼ˆå®é™…å€¼ä¸º44ï¼‰

// ç±»ç±»å‹éšå¼è½¬æ¢
class MyString {
public:
    MyString(const char*) { /* å…è®¸éšå¼è½¬æ¢ */ }
};
void processString(MyString s) {}
processString("hello");  // éšå¼æ„é€ MyStringå¯¹è±¡

// ä½¿ç”¨explicité˜»æ­¢éšå¼è½¬æ¢
class SafeInt {
public:
    explicit SafeInt(int x) : val(x) {}
private:
    int val;
};
// SafeInt s = 42;  // é”™è¯¯ï¼šexplicitæ„é€ å‡½æ•°ç¦æ­¢éšå¼è½¬æ¢
SafeInt s(42);      // æ­£ç¡®ï¼šæ˜¾å¼æ„é€ 
```

**å…³é”®é—®é¢˜**ï¼š

- æ•°å€¼ç±»å‹è½¬æ¢å¯èƒ½ä¸¢å¤±ç²¾åº¦æˆ–æº¢å‡º
- éšå¼æ„é€ å¯èƒ½äº§ç”Ÿéé¢„æœŸå¯¹è±¡
- è§£å†³æ–¹æ¡ˆï¼š
  - å¯ç”¨ç¼–è¯‘è­¦å‘Šï¼ˆ`-Wconversion`ï¼‰
  - å¯¹å•å‚æ•°æ„é€ å‡½æ•°ä½¿ç”¨`explicit`
  - ä½¿ç”¨`static_cast`æ˜¾å¼è½¬æ¢

---

### 2. åŠ¨æ€ç±»å‹è½¬æ¢ï¼ˆdynamic_castï¼‰

```cpp
class Base {
public:
    virtual ~Base() = default;  // å¿…é¡»åŒ…å«è™šå‡½æ•°
};
class Derived : public Base {};
class Unrelated {};

Base* b1 = new Derived;
Base* b2 = new Base;

// æŒ‡é’ˆè½¬æ¢ï¼ˆå¤±è´¥è¿”å›nullptrï¼‰
Derived* d1 = dynamic_cast<Derived*>(b1);  // æˆåŠŸ
Derived* d2 = dynamic_cast<Derived*>(b2);  // å¤±è´¥ï¼Œd2 == nullptr

// å¼•ç”¨è½¬æ¢ï¼ˆå¤±è´¥æŠ›bad_castå¼‚å¸¸ï¼‰
try {
    Derived& rd = dynamic_cast<Derived&>(*b2);  // æŠ›å‡ºstd::bad_cast
} catch (const std::bad_cast& e) {
    std::cerr << "è½¬æ¢å¤±è´¥: " << e.what() << "\n";
}
```

**RTTIä¾èµ–**ï¼š

- éœ€è¦å¯ç”¨è¿è¡Œæ—¶ç±»å‹ä¿¡æ¯ï¼ˆé»˜è®¤å¼€å¯ï¼Œå¯é€šè¿‡`-fno-rtti`ç¦ç”¨ï¼‰

- `typeid`è¿ç®—ç¬¦ç¤ºä¾‹ï¼š

  ```cpp
  #include <typeinfo>
  std::cout << typeid(*b1).name() << "\n";  // è¾“å‡ºç±»å‹åç§°ï¼ˆç¼–è¯‘å™¨ç›¸å…³ï¼‰
  ```

---

### 3. å¸¸é‡æ€§è½¬æ¢ï¼ˆconst_castï¼‰

```cpp
// åˆæ³•åœºæ™¯ï¼šå»é™¤åº•å±‚const
const int* pci = new int(10);
int* pi = const_cast<int*>(pci);  // åˆæ³•ä½†å±é™©
*pi = 20;  // è‹¥åŸå§‹å¯¹è±¡ä¸ºconstå®šä¹‰ï¼Œåˆ™UB

// å…¼å®¹æ—§æ¥å£æ¡ˆä¾‹
void legacy_print(char* str);
const char* msg = "hello";
legacy_print(const_cast<char*>(msg));  // å®‰å…¨ï¼Œå‰æä¸ä¿®æ”¹å†…å®¹

// é”™è¯¯ç”¨æ³•ç¤ºä¾‹
const int x = 42;
int* px = const_cast<int*>(&x);
*px = 100;  // æœªå®šä¹‰è¡Œä¸ºï¼
```

**å®‰å…¨å‡†åˆ™**ï¼š

- ä»…ç”¨äºå»é™¤éçœŸæ­£constçš„é™å®šï¼ˆå¦‚æŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡æœ¬èº«éconstï¼‰
- é¿å…ç”¨äºä¿®æ”¹åŸå§‹constå¯¹è±¡
- ä¼˜å…ˆä½¿ç”¨mutableæˆå‘˜å˜é‡æ›¿ä»£

---

## äºŒã€ç±»å‹æ¨æ–­ä¸å…ƒç¼–ç¨‹

---

### 1. `auto`ç±»å‹æ¨å¯¼

```cpp
const int& cr = 42;
auto a1 = cr;           // intï¼ˆå¿½ç•¥é¡¶å±‚constå’Œå¼•ç”¨ï¼‰
auto& a2 = cr;          // const int&
const auto a3 = cr;     // const int

// æ¨å¯¼è§„åˆ™å¯¹æ¯”
int arr[3];
auto p1 = arr;          // int*ï¼ˆæ•°ç»„é€€åŒ–ä¸ºæŒ‡é’ˆï¼‰
decltype(auto) p2 = arr;// int(&)[3]ï¼ˆä¿ç•™æ•°ç»„å¼•ç”¨ï¼‰

// å‡½æ•°è¿”å›ç±»å‹æ¨å¯¼
auto add(int a, int b) -> int { return a + b; }  // å°¾ç½®è¿”å›ç±»å‹
auto modern_add(auto a, auto b) { return a + b; } // C++20ç¼©å†™å‡½æ•°æ¨¡æ¿
```

**æ¨å¯¼è§„åˆ™**ï¼š

- å¿½ç•¥é¡¶å±‚constå’Œå¼•ç”¨
- æ•°ç»„/å‡½æ•°é€€åŒ–ä¸ºæŒ‡é’ˆ
- ä½¿ç”¨`decltype(auto)`ä¿ç•™å®Œæ•´ç±»å‹ä¿¡æ¯

---

### 2. `decltype`ä¸ç±»å‹ç‰¹å¾

```cpp
int x = 0;
const int& crx = x;

decltype(x) y = 10;         // int
decltype(crx) z = x;        // const int&
decltype((x)) ref = x;      // int&ï¼ˆæ‹¬å·å¯¼è‡´è¡¨è¾¾å¼ç±»å‹ï¼‰

// ç±»å‹ç‰¹å¾åº”ç”¨
#include <type_traits>
static_assert(std::is_same_v<decltype(x), int>);
static_assert(std::is_reference_v<decltype(ref)>);

// ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
template<typename T>
void process(T val) {
    if constexpr (std::is_pointer_v<T>) {
        std::cout << *val << "\n";
    } else {
        std::cout << val << "\n";
    }
}
```

---

### 3. ç±»å‹åˆ«åä¸æ¨¡æ¿

```cpp
// åŸºæœ¬ç±»å‹åˆ«å
using Byte = unsigned char;

// æ¨¡æ¿åˆ«å
template<typename T>
using Matrix = std::vector<std::vector<T>>;

Matrix<double> mat(3, std::vector<double>(3));

// å…ƒç¼–ç¨‹è¾…åŠ©
template<typename T>
using RemoveCVRef = std::remove_cv_t<std::remove_reference_t<T>>;

// ä½¿ç”¨ç¤ºä¾‹
RemoveCVRef<const int&> plain_int = 42;  // int
```

---

## ä¸‰ã€ç±»å‹è½¬æ¢æ€»ç»“è¡¨

| è½¬æ¢æ–¹å¼           | è¯­æ³•           | å®‰å…¨æ€§ | å…¸å‹åº”ç”¨åœºæ™¯               |
| ------------------ | -------------- | ------ | -------------------------- |
| éšå¼è½¬æ¢           | è‡ªåŠ¨           | ä½     | æ•°å€¼æå‡ã€ç±»æ„é€ å‡½æ•°       |
| `static_cast`      | æ˜¾å¼ç±»å‹è½¬æ¢   | ä¸­     | ç›¸å…³ç±»å‹è½¬æ¢ã€`void*`è½¬æ¢  |
| `dynamic_cast`     | è¿è¡Œæ—¶ç±»å‹æ£€æŸ¥ | é«˜     | å¤šæ€ç±»å‹å®‰å…¨å‘ä¸‹è½¬å‹       |
| `const_cast`       | å¸¸é‡æ€§ä¿®æ”¹     | ä½     | å…¼å®¹æ—§æ¥å£ã€å»é™¤`volatile` |
| `reinterpret_cast` | äºŒè¿›åˆ¶é‡æ–°è§£é‡Š | æœ€ä½   | åº•å±‚æŒ‡é’ˆæ“ä½œ               |

---

## æœ€ä½³å®è·µ

1. **ä¼˜å…ˆä½¿ç”¨C++é£æ ¼è½¬æ¢**ï¼š

   ```cpp
   // é¿å…Cé£æ ¼è½¬æ¢
   double d = 3.14;
   int i = static_cast<int>(d);  // æ›¿ä»£ (int)d
   ```

2. **ç±»å‹å®‰å…¨è®¾è®¡**ï¼š

   ```cpp
   // ä½¿ç”¨enum classæ›¿ä»£æ•´å‹æ ‡è®°
   enum class Mode { Read, Write };
   void set_mode(Mode m);  // ç±»å‹å®‰å…¨æ¥å£
   ```

3. **æ¨¡æ¿å…ƒç¼–ç¨‹æŠ€å·§**ï¼š

   ```cpp
   // SFINAEç±»å‹çº¦æŸï¼ˆC++11ï¼‰
   template<typename T>
   auto length(const T& t) -> decltype(t.size(), size_t()) {
       return t.size();
   }
   
   // C++20æ¦‚å¿µæ›¿ä»£æ–¹æ¡ˆ
   template<std::ranges::range R>
   size_t safe_length(R&& r) {
       return std::ranges::size(r);
   }
   ```

4. **è°ƒè¯•ç±»å‹ä¿¡æ¯**ï¼š

   ```cpp
   // è¿è¡Œæ—¶ç±»å‹ä¿¡æ¯è¾“å‡º
   template<typename T>
   void type_debug() {
       std::cout << "Type: " << typeid(T).name() 
                 << "\nSize: " << sizeof(T) << " bytes\n";
   }
   ```

5. **å®‰å…¨ç±»å‹æ“¦é™¤**ï¼š

   ```cpp
   // ä½¿ç”¨std::anyå’Œstd::variantæ›¿ä»£void*
   std::any data = std::make_any<std::string>("type safe");
   try {
       auto s = std::any_cast<std::string>(data);
   } catch (const std::bad_any_cast&) {
       // ç±»å‹ä¸åŒ¹é…å¤„ç†
   }
   ```

---

```cpp
// ç»¼åˆç¤ºä¾‹ï¼šå®‰å…¨ç±»å‹è½¬æ¢æ¡†æ¶
template<typename To, typename From>
To safe_cast(const From& from) {
    if constexpr (std::is_pointer_v<From> && std::is_polymorphic_v<std::remove_pointer_t<From>>) {
        // åŠ¨æ€æŒ‡é’ˆè½¬æ¢
        if (auto* result = dynamic_cast<To>(from)) 
            return result;
        throw std::bad_cast();
    } else if constexpr (std::is_convertible_v<From, To>) {
        // å®‰å…¨éšå¼è½¬æ¢
        return static_cast<To>(from);
    } else {
        // ä¸å…¼å®¹ç±»å‹
        static_assert(std::is_void_v<To>, "Types are not convertible");
    }
}
```

# é«˜çº§å†…å­˜æŠ€æœ¯

---

## ä¸€ã€å†…å­˜æ§åˆ¶

---

### 1. å†…å­˜æ± è®¾è®¡

```cpp
// ç®€æ˜“å†…å­˜æ± å®ç°ï¼ˆå›ºå®šå¤§å°å—ï¼‰
class MemoryPool {
    struct Block { Block* next; };
    Block* freeList = nullptr;
    size_t blockSize;
    size_t poolSize;

public:
    MemoryPool(size_t blockSize, size_t numBlocks)
        : blockSize(blockSize), poolSize(numBlocks * blockSize) {
        char* pool = new char[poolSize];
        for (size_t i = 0; i < numBlocks; ++i) {
            Block* blk = reinterpret_cast<Block*>(pool + i * blockSize);
            blk->next = freeList;
            freeList = blk;
        }
    }

    void* allocate() {
        if (!freeList) return nullptr;
        Block* blk = freeList;
        freeList = freeList->next;
        return blk;
    }

    void deallocate(void* ptr) {
        Block* blk = static_cast<Block*>(ptr);
        blk->next = freeList;
        freeList = blk;
    }

    ~MemoryPool() { delete[] reinterpret_cast<char*>(freeList); }
};

// ä½¿ç”¨ç¤ºä¾‹
MemoryPool pool(sizeof(int), 100);
int* num = static_cast<int*>(pool.allocate());
*num = 42;
pool.deallocate(num);
```

**ä¼˜åŒ–ä¼˜åŠ¿**ï¼š

- å‡å°‘å†…å­˜åˆ†é…ç³»ç»Ÿè°ƒç”¨å¼€é”€
- é¿å…å†…å­˜ç¢ç‰‡åŒ–
- æå‡ç¼“å­˜å±€éƒ¨æ€§ï¼ˆè¿ç»­åˆ†é…ï¼‰

---

### 2. è‡ªå®šä¹‰åˆ†é…å™¨

```cpp
#include <memory>

template<typename T>
class AlignedAllocator {
public:
    using value_type = T;
    
    AlignedAllocator() = default;

    template<typename U>
    AlignedAllocator(const AlignedAllocator<U>&) {}

    T* allocate(size_t n) {
        constexpr size_t alignment = alignof(T);
        void* ptr = aligned_alloc(alignment, n * sizeof(T));
        if (!ptr) throw std::bad_alloc();
        return static_cast<T*>(ptr);
    }

    void deallocate(T* p, size_t) {
        free(p);
    }
};

// åœ¨å®¹å™¨ä¸­ä½¿ç”¨
std::vector<int, AlignedAllocator<int>> vec;
vec.reserve(1024);  // å†…å­˜å¯¹é½åˆ†é…
```

**å…³é”®ç‰¹æ€§**ï¼š

- å®ç°`allocate`å’Œ`deallocate`æ–¹æ³•
- æ”¯æŒç±»å‹å¯¹é½è¦æ±‚ï¼ˆå¦‚SIMDæŒ‡ä»¤éœ€è¦16/32å­—èŠ‚å¯¹é½ï¼‰
- å¯ä¸æ ‡å‡†å®¹å™¨æ— ç¼é›†æˆ

---

## äºŒã€å¯¹è±¡ç”Ÿå‘½å‘¨æœŸç®¡ç†

---

### 1. Placement New

```cpp
// é¢„åˆ†é…å†…å­˜æ± 
alignas(std::string) char buffer[sizeof(std::string) * 10];

// åœ¨æŒ‡å®šä½ç½®æ„é€ å¯¹è±¡
std::string* s = new (buffer) std::string("Hello");

// æ˜¾å¼è°ƒç”¨ææ„å‡½æ•°
s->~basic_string();

// åº”ç”¨åœºæ™¯ï¼šå¯¹è±¡æ± 
class ObjectPool {
    std::vector<void*> memoryBlocks;
public:
    template<typename T, typename... Args>
    T* create(Args&&... args) {
        void* mem = allocate(sizeof(T));
        return new (mem) T(std::forward<Args>(args)...);
    }

    template<typename T>
    void destroy(T* obj) {
        obj->~T();
        deallocate(obj);
    }
};
```

**æ³¨æ„äº‹é¡¹**ï¼š

- å¿…é¡»æ‰‹åŠ¨ç®¡ç†å¯¹è±¡ç”Ÿå‘½å‘¨æœŸ
- å†…å­˜å¯¹é½éœ€æ»¡è¶³ç±»å‹è¦æ±‚
- ææ„é¡ºåºéœ€ä¸æ„é€ é¡ºåºç›¸å

---

### 2. ç§»åŠ¨è¯­ä¹‰ä¼˜åŒ–

```cpp
class Matrix {
    size_t rows, cols;
    std::unique_ptr<float[]> data;

public:
    Matrix(size_t r, size_t c) : rows(r), cols(c), 
        data(std::make_unique<float[]>(r * c)) {}

    // ç§»åŠ¨æ„é€ å‡½æ•°
    Matrix(Matrix&& other) noexcept 
        : rows(other.rows), cols(other.cols), data(std::move(other.data)) {
        other.rows = other.cols = 0;
    }

    // ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦
    Matrix& operator=(Matrix&& other) noexcept {
        if (this != &other) {
            rows = other.rows;
            cols = other.cols;
            data = std::move(other.data);
            other.rows = other.cols = 0;
        }
        return *this;
    }
};
```

**ä¼˜åŒ–æ•ˆæœ**ï¼š

- é¿å…å¤§è§„æ¨¡æ•°æ®æ‹·è´
- æ”¯æŒSTLå®¹å™¨çš„é«˜æ•ˆæ‰©å®¹
- æå‡èµ„æºè½¬ç§»æ•ˆç‡

---

## ä¸‰ã€åº•å±‚ä¼˜åŒ–

---

### 1. å†…å­˜å¯¹é½æ§åˆ¶

```cpp
struct Unoptimized {
    char c;     // 1å­—èŠ‚
    double d;   // 8å­—èŠ‚ï¼ˆéœ€è¦7å­—èŠ‚å¡«å……ï¼‰
    int i;      // 4å­—èŠ‚ï¼ˆéœ€è¦4å­—èŠ‚å¡«å……ï¼‰
};  // æ€»å¤§å°ï¼š1 + 7 + 8 + 4 + 4 = 24å­—èŠ‚

struct Optimized {
    double d;   // 8å­—èŠ‚
    int i;      // 4å­—èŠ‚
    char c;     // 1å­—èŠ‚ï¼ˆéœ€è¦3å­—èŠ‚å¡«å……ï¼‰
};  // æ€»å¤§å°ï¼š8 + 4 + 1 + 3 = 16å­—èŠ‚

// å¼ºåˆ¶å¯¹é½
struct alignas(64) CacheLineAligned {
    int data[16];
};  // ç¡®ä¿ç»“æ„ä½“ä¸CPUç¼“å­˜è¡Œå¯¹é½ï¼ˆé€šå¸¸64å­—èŠ‚ï¼‰
```

**ä¼˜åŒ–åŸåˆ™**ï¼š

- æŒ‰æˆå‘˜å¤§å°é™åºæ’åˆ—
- ä½¿ç”¨`alignof`æŸ¥è¯¢å¯¹é½è¦æ±‚
- é€šè¿‡`alignas`æŒ‡å®šç‰¹æ®Šå¯¹é½

---

### 2. åŸå­æ“ä½œä¸å†…å­˜é¡ºåº

```cpp
#include <atomic>
#include <thread>

std::atomic<int> counter{0};

void increment(int n) {
    for (int i = 0; i < n; ++i) {
        counter.fetch_add(1, std::memory_order_relaxed);
    }
}

// å†…å­˜å±éšœç¤ºä¾‹
std::atomic<bool> flag{false};
int data = 0;

void producer() {
    data = 42;  // æ™®é€šå†™æ“ä½œ
    flag.store(true, std::memory_order_release);
}

void consumer() {
    while (!flag.load(std::memory_order_acquire));
    assert(data == 42);  // ä¿è¯çœ‹åˆ°producerçš„å†™æ“ä½œ
}
```

**å†…å­˜é¡ºåºç±»å‹**ï¼š

- `memory_order_relaxed`ï¼šæ— é¡ºåºä¿è¯ï¼ˆè®¡æ•°å™¨ï¼‰
- `memory_order_acquire/release`ï¼šåŒæ­¥ç‰¹å®šå†…å­˜è®¿é—®
- `memory_order_seq_cst`ï¼šå…¨å±€é¡ºåºä¿è¯ï¼ˆé»˜è®¤ï¼‰

---

## å››ã€å¹¶å‘å†…å­˜æ¨¡å‹

---

### 1. æ— é”æ•°æ®ç»“æ„çš„å†…å­˜å›æ”¶

```cpp
// Hazard Pointer ç¤ºä¾‹
template<typename T>
class LockFreeStack {
    struct Node {
        T data;
        Node* next;
    };

    std::atomic<Node*> head;
    thread_local static std::vector<Node*> retired;  // çº¿ç¨‹æœ¬åœ°å›æ”¶åˆ—è¡¨

    void retire(Node* old) {
        retired.push_back(old);
        if (retired.size() >= 100) {
            scan();  // å®šæœŸå®‰å…¨å›æ”¶
        }
    }

    void scan() {
        // æ£€æŸ¥å…¶ä»–çº¿ç¨‹æ˜¯å¦æ­£åœ¨è®¿é—®å¾…å›æ”¶èŠ‚ç‚¹
        // å®‰å…¨æ—¶æ‰§è¡Œdeleteæ“ä½œ
    }

public:
    void push(const T& value) {
        Node* new_node = new Node{value, head.load()};
        while (!head.compare_exchange_weak(new_node->next, new_node));
    }

    bool pop(T& value) {
        Node* old_head = head.load();
        // æ³¨å†ŒHazard Pointer
        do {
            if (!old_head) return false;
        } while (!head.compare_exchange_weak(old_head, old_head->next));
        value = old_head->data;
        retire(old_head);
        return true;
    }
};
```

**Hazard PointeråŸç†**ï¼š

1. æ¯ä¸ªçº¿ç¨‹ç»´æŠ¤æ­£åœ¨è®¿é—®çš„æŒ‡é’ˆåˆ—è¡¨
2. å»¶è¿Ÿå›æ”¶å¯èƒ½è¢«å…¶ä»–çº¿ç¨‹è®¿é—®çš„å†…å­˜
3. å®šæœŸæ‰«æç¡®å®šå®‰å…¨å›æ”¶æ—¶æœº

---

## é«˜çº§å†…å­˜æŠ€æœ¯å¯¹æ¯”

| æŠ€æœ¯           | é€‚ç”¨åœºæ™¯       | ä¼˜ç‚¹                | ç¼ºç‚¹                 |
| -------------- | -------------- | ------------------- | -------------------- |
| å†…å­˜æ±          | é«˜é¢‘å°å¯¹è±¡åˆ†é… | å‡å°‘ç¢ç‰‡ï¼Œå¿«é€Ÿåˆ†é…  | å›ºå®šå—å¤§å°ï¼Œçµæ´»æ€§ä½ |
| è‡ªå®šä¹‰åˆ†é…å™¨   | ç‰¹æ®Šå†…å­˜éœ€æ±‚   | ä¸STLé›†æˆï¼Œæ§åˆ¶åº•å±‚ | å®ç°å¤æ‚ï¼Œè°ƒè¯•å›°éš¾   |
| Placement New  | å¯¹è±¡å¤ç”¨åœºæ™¯   | é¿å…é‡å¤å†…å­˜åˆ†é…    | ç”Ÿå‘½å‘¨æœŸç®¡ç†å¤æ‚     |
| åŸå­æ“ä½œ       | å¤šçº¿ç¨‹å…±äº«æ•°æ® | æ— é”å¹¶å‘            | å†…å­˜é¡ºåºç†è§£æˆæœ¬é«˜   |
| Hazard Pointer | æ— é”æ•°æ®ç»“æ„   | å®‰å…¨å†…å­˜å›æ”¶        | å®ç°å¤æ‚ï¼Œæ€§èƒ½å¼€é”€   |

---

## æœ€ä½³å®è·µ

1. **ä¼˜å…ˆä½¿ç”¨æ ‡å‡†åº“å·¥å…·**ï¼š

   ```cpp
   // ä½¿ç”¨std::pmr::memory_resourceå®ç°å†…å­˜æ± 
   #include <memory_resource>
   std::pmr::unsynchronized_pool_resource pool;
   std::pmr::vector<int> vec{&pool};
   ```

2. **æ€§èƒ½æ•æ„Ÿä»£ç ä¼˜åŒ–**ï¼š

   ```cpp
   // é¢„åˆ†é…å†…å­˜é¿å…è¿è¡Œæ—¶åˆ†é…
   static thread_local std::vector<int> local_buffer;
   local_buffer.reserve(1024);
   ```

3. **å†…å­˜è¯Šæ–­å·¥å…·é›†æˆ**ï¼š

   ```bash
   # ä½¿ç”¨gperftoolsåˆ†æå†…å­˜åˆ†é…
   HEAPPROFILE=./heap_profile ./your_program
   pprof --svg ./your_program ./heap_profile.0001.heap > profile.svg
   ```

4. **è·¨å¹³å°å¯¹é½å¤„ç†**ï¼š

   ```cpp
   #if defined(_MSC_VER)
   #define ALIGNED_ALLOC(size, align) _aligned_malloc(size, align)
   #else
   #define ALIGNED_ALLOC(size, align) aligned_alloc(align, size)
   #endif
   ```

5. **æ— é”ç¼–ç¨‹å‡†åˆ™**ï¼š

   - é¿å…åœ¨æ— é”ä»£ç ä¸­æ‰§è¡Œé˜»å¡æ“ä½œ
   - ä½¿ç”¨æˆç†Ÿçš„åŸå­æ“ä½œåº“ï¼ˆå¦‚Follyçš„AtomicHashMapï¼‰
   - å®šæœŸè¿›è¡Œç«æ€æ¡ä»¶æ£€æµ‹ï¼ˆTSanå·¥å…·ï¼‰

---

```cpp
// ç»¼åˆç¤ºä¾‹ï¼šå†…å­˜æ± æ”¯æŒçš„STLå®¹å™¨
template<typename T>
using PoolAllocatedVector = std::vector<T, AlignedAllocator<T>>;

void process_data() {
    // ä½¿ç”¨è‡ªå®šä¹‰å†…å­˜æ± 
    static MemoryPool pool(sizeof(float), 4096);
    
    PoolAllocatedVector<float> data;
    data.reserve(1000);  // ä»å†…å­˜æ± åˆ†é…
    
    // å¹¶è¡Œå¤„ç†ï¼ˆæ— é”ï¼‰
    std::atomic<int> processed{0};
    #pragma omp parallel for
    for (int i = 0; i < 1000; ++i) {
        data[i] = compute_value(i);
        processed.fetch_add(1, std::memory_order_relaxed);
    }
}
```

# æ‰©å±•ä¸å®è·µ

---

## ä¸€ã€ç°ä»£C++æ–°ç‰¹æ€§

---

### 1. C++17 `std::byte` ä¸å†…å­˜æ“ä½œ

```cpp
#include <cstddef>
#include <cstring>

void memory_ops_example() {
    std::byte buffer[16];  // æœªåˆå§‹åŒ–çš„åŸå§‹å†…å­˜
    std::memset(buffer, 0xAA, sizeof(buffer));  // å¡«å……æ•°æ®

    // ç±»å‹å®‰å…¨çš„å†…å­˜æ“ä½œ
    std::byte* ptr = buffer;
    *(reinterpret_cast<uint32_t*>(ptr)) = 0xDEADBEEF;  // ä¼ ç»Ÿæ–¹å¼
    std::to_address(ptr + 4);  // C++17å®‰å…¨è·å–åœ°å€

    // å†…å­˜æ„é€ /ææ„
    struct Data { int x; float y; };
    Data* data = new (buffer) Data{42, 3.14f};  // Placement new
    data->~Data();  // æ˜¾å¼ææ„
}

// std::byteç‰¹æ€§ï¼š
// - æ˜ç¡®è¡¨ç¤ºåŸå§‹å†…å­˜ï¼ˆéå­—ç¬¦ç±»å‹ï¼‰
// - æ”¯æŒä½è¿ç®—æ“ä½œï¼ˆ|, &, ~, ^ï¼‰
```

---

### 2. C++20 å†…å­˜å·¥å…·

```cpp
#include <memory>

struct Widget {
    int id;
    std::string name;
};

void cpp20_memory_ops() {
    // åˆ†é…æœªåˆå§‹åŒ–å†…å­˜
    Widget* w = static_cast<Widget*>(::operator new(sizeof(Widget)));
    
    // C++20å®‰å…¨æ„é€ /ææ„
    std::construct_at(w, 1001, "C++20");  // æ›¿ä»£placement new
    std::destroy_at(w);                   // æ›¿ä»£æ˜¾å¼ææ„è°ƒç”¨
    
    ::operator delete(w);
}

// ä¼˜åŠ¿ï¼š
// 1. æ›´æ¸…æ™°çš„è¯­ä¹‰
// 2. æ”¯æŒconstexprä¸Šä¸‹æ–‡
// 3. æ›´å¥½çš„å¼‚å¸¸å®‰å…¨ä¿è¯
```

---

## äºŒã€å®æˆ˜æ¡ˆä¾‹

---

### 1. å®ç°ç®€æ˜“åŠ¨æ€æ•°ç»„

```cpp
template<typename T>
class SimpleVector {
    T* data = nullptr;
    size_t capacity = 0;
    size_t size = 0;

    void reallocate(size_t new_cap) {
        T* new_data = static_cast<T*>(::operator new(new_cap * sizeof(T)));
        
        // ç§»åŠ¨å·²æœ‰å…ƒç´ 
        for (size_t i=0; i<size; ++i) {
            new (new_data+i) T(std::move(data[i]));
            data[i].~T();
        }
        
        ::operator delete(data);
        data = new_data;
        capacity = new_cap;
    }

public:
    void push_back(const T& value) {
        if (size >= capacity) {
            reallocate(capacity ? capacity*2 : 1);
        }
        new (data + size) T(value);  // Placement new
        ++size;
    }

    T& operator[](size_t index) { 
        return data[index]; 
    }

    ~SimpleVector() {
        for (size_t i=0; i<size; ++i) {
            data[i].~T();
        }
        ::operator delete(data);
    }
};

// ä½¿ç”¨ç¤ºä¾‹
SimpleVector<std::string> vec;
vec.push_back("Modern");
vec.push_back("C++");
```

**å…³é”®ä¼˜åŒ–**ï¼š

- ç§»åŠ¨è¯­ä¹‰å‡å°‘æ‹·è´å¼€é”€
- å¼‚å¸¸å®‰å…¨ä¿è¯ï¼ˆå¦‚æœæ„é€ å¤±è´¥è‡ªåŠ¨ææ„å·²åˆ›å»ºå¯¹è±¡ï¼‰
- ç²¾ç¡®æ§åˆ¶å†…å­˜ç”Ÿå‘½å‘¨æœŸ

---

### 2. å¤šçº¿ç¨‹å†…å­˜ç®¡ç†

```cpp
#include <mutex>
#include <atomic>
#include <vector>

class ThreadSafeAllocator {
    std::mutex mtx;
    std::vector<void*> free_list;
    std::atomic<size_t> total_allocs{0};

public:
    void* allocate(size_t size) {
        std::lock_guard<std::mutex> lock(mtx);
        if (!free_list.empty()) {
            auto ptr = free_list.back();
            free_list.pop_back();
            return ptr;
        }
        total_allocs.fetch_add(1, std::memory_order_relaxed);
        return ::operator new(size);
    }

    void deallocate(void* ptr) noexcept {
        std::lock_guard<std::mutex> lock(mtx);
        free_list.push_back(ptr);
    }

    ~ThreadSafeAllocator() {
        for (auto ptr : free_list) {
            ::operator delete(ptr);
        }
    }
};

// ä½¿ç”¨ç¤ºä¾‹
ThreadSafeAllocator allocator;

void worker() {
    int* arr = static_cast<int*>(allocator.allocate(1024 * sizeof(int)));
    // ä½¿ç”¨å†…å­˜...
    allocator.deallocate(arr);
}
```

**çº¿ç¨‹å®‰å…¨ç­–ç•¥**ï¼š

- äº’æ–¥é”ä¿æŠ¤ç©ºé—²åˆ—è¡¨
- åŸå­è®¡æ•°å™¨ç»Ÿè®¡åˆ†é…æ¬¡æ•°
- å¯¹è±¡æ± å‡å°‘ç³»ç»Ÿè°ƒç”¨

---

## ä¸‰ã€è°ƒè¯•å·¥å…·é“¾

---

### 1. GDBå†…å­˜è°ƒè¯•

```bash
# ç¼–è¯‘å¸¦è°ƒè¯•ä¿¡æ¯
g++ -g -O0 -o test test.cpp

# å¯åŠ¨GDB
gdb ./test

# å¸¸ç”¨å‘½ä»¤
(gdb) break main            # è®¾ç½®æ–­ç‚¹
(gdb) run                   # å¯åŠ¨ç¨‹åº
(gdb) print sizeof(Data)    # æŸ¥çœ‹ç±»å‹å¤§å°
(gdb) x/16xb &buffer        # æŸ¥çœ‹å†…å­˜åå…­è¿›åˆ¶å†…å®¹
(gdb) info registers        # æŸ¥çœ‹å¯„å­˜å™¨çŠ¶æ€
(gdb) backtrace             # æŸ¥çœ‹è°ƒç”¨æ ˆ
```

**å†…å­˜å¸ƒå±€è§‚å¯ŸæŠ€å·§**ï¼š

- ä½¿ç”¨`pahole`å·¥å…·åˆ†æç»“æ„ä½“å¸ƒå±€
- é€šè¿‡`ptype`å‘½ä»¤æŸ¥çœ‹ç±»å‹ä¿¡æ¯
- `watch`å‘½ä»¤ç›‘æ§å†…å­˜å˜åŒ–

---

### 2. æ€§èƒ½åˆ†æå·¥å…·

```bash
# ä½¿ç”¨perfè¿›è¡Œæ€§èƒ½åˆ†æ
perf record -g ./your_program   # è®°å½•æ€§èƒ½æ•°æ®
perf report                     # æŸ¥çœ‹çƒ­ç‚¹åˆ†æ

# Intel VTuneåŸºæœ¬ä½¿ç”¨
vtune -collect hotspots -result-dir vtune_data ./your_program
vtune -report summary -result-dir vtune_data

# Valgrindå†…å­˜æ£€æµ‹
valgrind --tool=memcheck --leak-check=full ./your_program
```

**æ€§èƒ½ä¼˜åŒ–é‡ç‚¹**ï¼š

- ç¼“å­˜æœªå‘½ä¸­ï¼ˆCache missesï¼‰
- åˆ†æ”¯é¢„æµ‹å¤±è´¥ï¼ˆBranch mispredictionsï¼‰
- å†…å­˜åˆ†é…çƒ­ç‚¹ï¼ˆMemory allocation hotspotsï¼‰

---

## å››ã€ç°ä»£C++å·¥ç¨‹å®è·µ

---

### 1. æ¨¡å—åŒ–ç¼–ç¨‹ï¼ˆC++20 Modulesï¼‰

```cpp
// math.ixx
export module math;

export namespace math {
    template<typename T>
    T add(T a, T b) { return a + b; }
}

// main.cpp
import math;

int main() {
    auto result = math::add(3.14, 2.718);
    return 0;
}
```

**ä¼˜åŠ¿**ï¼š

- åŠ å¿«ç¼–è¯‘é€Ÿåº¦
- é¿å…å¤´æ–‡ä»¶é‡å¤åŒ…å«
- æ›´å¥½çš„å°è£…æ€§

---

### 2. åç¨‹å®è·µï¼ˆC++20ï¼‰

```cpp
#include <coroutine>
#include <iostream>

struct Generator {
    struct promise_type {
        int current_value;
        
        Generator get_return_object() { 
            return Generator{std::coroutine_handle<promise_type>::from_promise(*this)};
        }
        auto initial_suspend() { return std::suspend_always{}; }
        auto final_suspend() noexcept { return std::suspend_always{}; }
        void return_void() {}
        auto yield_value(int value) {
            current_value = value;
            return std::suspend_always{};
        }
        void unhandled_exception() { std::terminate(); }
    };

    std::coroutine_handle<promise_type> handle;
    
    bool next() { 
        if (!handle.done()) {
            handle.resume();
            return !handle.done();
        }
        return false;
    }
    int value() { return handle.promise().current_value; }
    ~Generator() { if (handle) handle.destroy(); }
};

Generator range(int start, int end) {
    for (int i = start; i < end; ++i) {
        co_yield i;
    }
}

// ä½¿ç”¨ç¤ºä¾‹
int main() {
    auto gen = range(1, 5);
    while (gen.next()) {
        std::cout << gen.value() << " ";  // è¾“å‡º1 2 3 4
    }
}
```

---

## äº”ã€æŒç»­é›†æˆä¸è´¨é‡ä¿è¯

---

### 1. é™æ€åˆ†æé›†æˆ

```yaml
# .github/workflows/ci.yml
name: C++ CI

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Static Analysis
      run: |
        clang-tidy --checks='*' src/*.cpp --
        cppcheck --enable=all src/
```

**æ¨èå·¥å…·**ï¼š

- Clang-Tidyï¼ˆä»£ç é£æ ¼ã€æ½œåœ¨é”™è¯¯ï¼‰
- Cppcheckï¼ˆå†…å­˜æ³„æ¼ã€æœªå®šä¹‰è¡Œä¸ºï¼‰
- SonarQubeï¼ˆä»£ç è´¨é‡é—¨æˆ·ï¼‰

---

### 2. æ€§èƒ½åŸºå‡†æµ‹è¯•

```cpp
#include <benchmark/benchmark.h>

static void BM_VectorPushBack(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<int> v;
        v.reserve(state.range(0));
        for (int i = 0; i < state.range(0); ++i) {
            v.push_back(i);
        }
    }
}
BENCHMARK(BM_VectorPushBack)->Arg(100)->Arg(1000);

BENCHMARK_MAIN();
```

**æµ‹è¯•è¦ç‚¹**ï¼š

- å¤šå°ºå¯¸å‚æ•°æµ‹è¯•ï¼ˆ`->ArgsProduct({{100, 1000}, {64, 256}})`ï¼‰
- å†…å­˜åˆ†é…è¿½è¸ªï¼ˆ`benchmark::MemoryUsage()`ï¼‰
- ç»“æœå¯è§†åŒ–ï¼ˆGoogle Chartsæˆ–Python Matplotlibï¼‰

---

## å·¥ç¨‹å®è·µæ€»ç»“

| å®è·µé¢†åŸŸ     | æ¨èå·¥å…·/æŠ€æœ¯          | å…³é”®æ”¶ç›Š               |
| ------------ | ---------------------- | ---------------------- |
| å†…å­˜ç®¡ç†     | è‡ªå®šä¹‰åˆ†é…å™¨ã€å†…å­˜æ±    | æ€§èƒ½æå‡ï¼Œå‡å°‘ç¢ç‰‡     |
| å¹¶å‘ç¼–ç¨‹     | åŸå­æ“ä½œã€æ— é”æ•°æ®ç»“æ„ | é«˜ååé‡ï¼Œä½å»¶è¿Ÿ       |
| ä»£ç è´¨é‡     | Clang-Tidyã€SonarQube  | å‡å°‘ç¼ºé™·ï¼Œæå‡å¯ç»´æŠ¤æ€§ |
| æ€§èƒ½ä¼˜åŒ–     | perfã€VTune            | å®šä½ç“¶é¢ˆï¼Œç²¾å‡†ä¼˜åŒ–     |
| ç°ä»£è¯­è¨€ç‰¹æ€§ | åç¨‹ã€æ¨¡å—ã€æ¦‚å¿µ       | æå‡å¼€å‘æ•ˆç‡ï¼Œä»£ç ç®€æ´ |

---

```cpp
// ç»¼åˆç¤ºä¾‹ï¼šç°ä»£C++å·¥ç¨‹æ¨¡æ¿
import std.core;  // C++23æ ‡å‡†åº“æ¨¡å—

template<std::integral T>  // C++20æ¦‚å¿µçº¦æŸ
class ThreadSafeCache {
    std::unordered_map<T, std::string> cache;
    mutable std::shared_mutex mtx;

public:
    void update(T id, std::string value) {
        std::unique_lock lock(mtx);
        cache[id] = std::move(value);
    }

    std::optional<std::string> get(T id) const {
        std::shared_lock lock(mtx);
        if (auto it = cache.find(id); it != cache.end()) {
            return it->second;
        }
        return std::nullopt;
    }
};

// ä½¿ç”¨åç¨‹å¼‚æ­¥åŠ è½½
Task<void> async_load_data(ThreadSafeCache<int>& cache) {
    auto data = co_await fetch_from_network();
    cache.update(data.id, data.content);
}
```