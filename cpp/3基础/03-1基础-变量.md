[TOC]

# 变量

数据类型是程序的基础：它告诉我们数据的意义以及能在数据上执行的操作。
##  基本内置类型

基本内置类型包括了算术类型和空类型。
### 算术类型

算术类型分为两类：整型和浮点型。
#### 算术类型

| 类型            | 含义               | 最小尺寸（字节） | 能够表示的范围                              |
| ------------- | ---------------- | -------- | ------------------------------------ |
| `char`        | 字符类型             | 1        | -128 到 127（有符号）或 0 到 255（无符号）        |
| `wchar_t`     | 宽字符类型            | 2或4      | 依赖于实现，通常至少能表示所有Unicode字符             |
| `char16_t`    | 用于存储16位Unicode字符 | 2        | 0 到 65535（U+0000 到 U+FFFF）           |
| `char32_t`    | 用于存储32位Unicode字符 | 4        | 0 到 4294967295（U+0000 到 U+10FFFF）    |
| `int`         | 整数类型             | 2        | -2^31 到 2^31-1（有符号）或 0 到 2^32-1（无符号） |
| `short`       | 短整型              | 2        | -2^15 到 2^15-1（有符号）或 0 到 2^16-1（无符号） |
| `long`        | 长整型              | 4        | -2^31 到 2^31-1（有符号）或 0 到 2^32-1（无符号） |
| `long long`   | 超长整型             | 8        | -2^63 到 2^63-1（有符号）或 0 到 2^64-1（无符号） |
| `float`       | 单精度浮点数           | 4        | 约 1.2E-38 到 3.4E38                   |
| `double`      | 双精度浮点数           | 8        | 约 2.3E-308 到 1.8E308                 |
| `long double` | 扩展精度浮点数          | 8或更大     | 通常比`double`更精确                       |
| `bool`        | 布尔类型             | 1        | true 或 false                         |
- 整型：`int `，`short`， `long`， `long long`，字符型，`bool`。
- 浮点型：`float`，`double`，`long double`。
- 字符类型：char确保可以存放机器基本字符集中任意字符对应的数字值，char的大小和一个机器字节是一样的。其他字符类型用于扩展字符集。

#### 算术类型的尺寸

算数类型的尺寸：该类型数据所占的比特数。
- 算数类型的尺寸不同电脑上有所差异。
- C++标准仅规定了不同尺寸的最小值，允许编译器赋予这些类型更大的尺寸。（大多都比规定的大）
- 所占的比特数不同，所能表示的数据范围也不一样。
- 尺寸可以用`sizeof()`编译时运算符获取。
#### 符号

除了布尔型和拓展的字符型之外，其他整型都可以划分为带符号和无符号的。在类型名前添加unsigned就可以得到无符号类型。值得注意的是：char类型只会表现为无符号和有符号中的一种，由编译器决定。

### 类型选择

- **当明确知晓数值不可能为负时，选用无符号类型**。
- **使用整型时常使用int。如果你的数值超过了int的表示范围,选用long long**。
- **在算术表达式中不要使用char或bool**。因为类型char在一些机器上是有符号的,而在另一些机器上又是无符号的。
- **执行浮点数运算选用 double**，这是因为 float 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说,双精度运算甚至比单精度还快。long double 提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。
### 类型转换

**类型转换**：将对象从一种给定的类型转换为另一种相关类型。

**隐式类型转换：**

- 把一个非布尔类型的算术值赋给布尔类型时，初始值为`0`则结果为`false`，否则结果为`true`。
- 把一个布尔值赋给非布尔类型时，初始值为false则结果为`0`，初始值为`true`则结果为`1`。
- 把一个浮点数赋给整数类型时，结果值将仅保留浮点数中小数点之前的部分。
- 把一个整数值赋给浮点类型时，小数部分记为`0`。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。
- 给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。
- 当我们赋给带符号类型一个超出它表示范围的值时，结果是**未定义的(undefined)**。程序可能继续工作、可能崩溃，也可能生成垃圾数据。

**显示类型转换(强制类型转换)**：

1. **静态类型转换（Static Cast）**
   - 用于基本数据类型之间的转换，比如将`float`转换为`int`，或者将派生类指针转换为基类指针。
   - 它不会进行运行时类型检查，因此不能用于多态类型转换。
   - 语法：`static_cast<type>(expression)`
2. **动态类型转换（Dynamic Cast）**
   - 用于类的层次结构中的向下转换（从基类指针或引用转换为派生类指针或引用），并且要求进行运行时类型检查。
   - 只能用于包含虚函数的类的指针或引用。
   - 如果转换失败，返回`nullptr`（对于指针）或抛出异常（对于引用）。
   - 语法：`dynamic_cast<type>(expression)`
3. **重新解释类型转换（Reinterpret Cast）**
   - 用于低级别的重新解释转换，比如将指针转换为足够大的整数类型，或者将整数转换为指针。
   - 它不进行任何检查，因此使用时需要非常小心，因为它可能会导致未定义行为。
   - 语法：`reinterpret_cast<type>(expression)`
4. **常量类型转换（Const Cast）**
   - 用于移除或添加`const`或`volatile`属性。
   - 不改变表达式的值类型。
   - 语法：`const_cast<type>(expression)`

### 字面值常量

每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

- 整数型：以`0`开头的整数代表八进制数,以`0x`或`0X`开头的代表十六进制数。
- 浮点数型：用一个小数或以科学计数法表示的指数，其中指数部分用`E`或`e`标识。
- 转义序列：一类是不可打印的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符(单引号、双引号、问号、反斜线)。转义序列均以反斜线作为开始。
- ![Pasted image 20241110135920](./assets/Pasted%20image%2020241110135920-1732600609834-1.png)
- 指定字面值的类型：添加前缀和后缀可以改变字面值的默认类型。
- ![Pasted image 20241110140014](./assets/Pasted%20image%2020241110140014-1732600631100-3.png)
- 布尔字面值：`true`，`false`。
- 指针字面值：`nullptr`。

## 变量

变量提供一个**具名的**、**可供程序操作的存储空间**。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。

对C++程序员来说, "变量(variable)”和“对象(object)”一般可以互换使用。

###  定义

#### 基本形式

变量定义的基本形式是：首先是类型说明符，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔,最后以分号结束。列表中每个变量名的类型都由类型说明符指定，定义时还可以为一个或多个变量赋初值。

#### 初始值

**初始化**：对象在创建时获得一个**特定**的值。

**初始化不是赋值**，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

**列表初始化(C++11)**

列表初始化的基本语法如下：

```cpp
Type var{value1, value2, ...};
```

或者对于数组和聚合类型：

```cpp
Type arr[] = {value1, value2, ...};
```

**特点**

1. 统一初始化语法：无论是对象、数组还是聚合类型，都可以使用相同的语法进行初始化。
2. 避免窄化转换：列表初始化不允许隐式的窄化转换，这可以避免一些因类型不匹配而导致的数据丢失问题。
3. 直接初始化：对于非聚合类型，列表初始化是直接初始化，而不是默认初始化后赋值，这意味着它可以直接初始化非静态成员变量和基类部分。
4. 完美转发：在函数模板中，使用列表初始化可以实现参数的完美转发。

**默认初始化**

如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。定义在`main`函数中的默认初始化为垃圾数据，定义在`main`外的初始化为0。

如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是**未定义的**，如果试图拷贝或以其他形式访问此类值将引发错误。

#### 声明和定义的关系

为了支持分离式编译，C++语言将声明和定义区分开来。声明使得名字为程序所知,一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义负责创建与名字关联的实体。

变量声明规定了变量的类型和名字，定义还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`，而且不要显式地初始化变量
### 标识符

C++的标识符由字母、数字和下画线组成，其中必须以字母或下画线开头。标识符的长度没有限制,但是对大小写字母敏感。

C++语言保留了一些名字供语言本身使用，这些名字不能被用作标识符。C++也为标准库保留了一些名字。自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。定义在函数体外的标识符不能以下画线开头。

#### 命名规范

常见的变量命名规范：

1. **驼峰命名法**（推荐）
   - **小驼峰命名法**：第一个单词以小写字母开始，后续单词首字母大写。例如：`myVariableName`。
   - **大驼峰命名法：每个单词的首字母都大写，通常用于类名。例如：`MyVariableName`。
2. **下划线命名法**
   - 单词之间用下划线分隔。例如：`my_variable_name`。
3. **匈牙利命名法**
   - 变量名前加上表示类型的前缀。例如：`strName`（字符串类型），`iCount`（整型）。
4. **帕斯卡命名法**
   - 与大驼峰命名法类似，每个单词的首字母都大写，通常用于类名和接口名。例如：`PascalCaseName`。
5. **K&R命名法**
   - 通常用于C语言，小写字母，单词间不加空格或下划线。例如：`kernighanRitchie`。
6. **下划线和大写字母混合命名法**
   - 单词间用下划线分隔，每个单词首字母大写。例如：`MY_VARIABLE_NAME`。
7. **全大写字母命名法**
   - 所有字母都大写，单词间用下划线分隔。例如：`MY_VARIABLE_NAME`。这种命名法常用于常量。
8. **单词缩写命名法**
   - 对于非常长的单词，可以使用缩写。例如：`maxVal`。
9. **单字母命名法**
   - 对于简单的循环计数器或临时变量，可以使用单字母命名，如`i`、`j`、`k`等。
10. **描述性命名**
    - 变量名应该尽可能描述变量的用途或含义，避免使用模糊不清的名称，如`data`、`info`等。
11. **避免使用数字和特殊字符**
    - 变量名中避免使用数字和特殊字符，除非它们是变量名的一部分，如`version2`。

#### 标志符的作用域

TODO

## 复合类型

### 引用



### 指针



### 复合复合类型



## const限定符



## 处理类型

### 类型别名



### auto类型说明符



### decltype类型指示符



## 自定义数据结构



### 定义结构体



### 使用结构体



## 多文件
