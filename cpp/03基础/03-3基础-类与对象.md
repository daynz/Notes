<!-- vscode-markdown-toc -->
* 1. [成员变量](#)
	* 1.1. [内置类型](#-1)
		* 1.1.1. [基本内置类型](#-1)
		* 1.1.2. [指针类型与引用类型](#-1)
		* 1.1.3. [使用STL库](#STL)
	* 1.2. [自定义类型](#-1)
		* 1.2.1. [其他类](#-1)
		* 1.2.2. [结构体、枚举、类型别名](#-1)
	* 1.3. [初始化](#-1)
	* 1.4. [const成员变量](#const)
	* 1.5. [static成员变量](#static)
* 2. [成员函数](#-1)
	* 2.1. [基本成员函数](#-1)
	* 2.2. [const成员函数](#const-1)
	* 2.3. [static成员函数](#static-1)
		* 2.3.1. [成员函数重载](#-1)
* 3. [this](#this)
	* 3.1. [this用法](#this-1)
* 4. [类作用域(Scope)](#Scope)
* 5. [友元（Friend）](#Friend)
	* 5.1. [友元函数](#-1)
	* 5.2. [友元类](#-1)
	* 5.3. [注意事项](#-1)
* 6. [类类型](#-1)
* 7. [继承与动态绑定](#-1)
	* 7.1. [基类](#-1)
	* 7.2. [派生类](#-1)
	* 7.3. [动态绑定](#-1)
	* 7.4. [虚函数](#-1)
	* 7.5. [继承与静态成员](#-1)
	* 7.6. [继承与类型转换](#-1)
	* 7.7. [继承与控制访问](#-1)
	* 7.8. [继承与类作用域](#-1)
	* 7.9. [继承与友元](#-1)
* 8. [拷贝控制](#-1)
	* 8.1. [构造](#-1)
	* 8.2. [拷贝](#-1)
	* 8.3. [赋值](#-1)
	* 8.4. [析构](#-1)
	* 8.5. [移动](#-1)
* 9. [重载运算](#-1)
	* 9.1. [基本概念](#-1)
	* 9.2. [重载运算例](#-1)

类的基本思想是数据抽象和封装。
- 数据抽象：依赖与接口和实现分离的编程技术。
	- 接口：包括用户所能执行的操作。
	- 实现：包括类的成员、负责接口实现的函数体以及定义类所需的各种私有函数。
- 封装：实现了类的接口和实现的分离。封装后的类隐藏了实现细节，类的用户只能使用接口而无法访问实现部分。

# 数据抽象和封装

##  1. <a name=''></a>成员变量

成员变量是类中定义的变量，可以使用各种数据类型，用于存储与类的对象相关的数据。成员变量可称为属性。
###  1.1. <a name='-1'></a>内置类型

####  1.1.1. <a name='-1'></a>基本内置类型

- 定义：默认不会初始化，初始值是未定义的（未定义行为）。可以给定初始值。
- 初始化：非必须
- 构造：构造时需要初始化，创建时自动分配内存。
- 析构：不需要做任何处理，不需要显式分配或释放内存。

最好在构造函数中初始化成员变量，或在声明时给定初始值。
基本内置类型的成员变量在对象创建时自动分配内存，不需要显式分配或释放内存。
####  1.1.2. <a name='-1'></a>指针类型与引用类型

**使用时要注意动态内存管理**

- 定义：默认不会初始化，初始值是未定义的（未定义行为），可能是未知的地址。可能导致悬空指针或内存泄漏。
- 构造：构造时需要初始化，分配内存。也可初始化为`nullptr`
- 析构：必须释放指针成员变量所指向的动态分配的内存，以防止内存泄漏。确保在释放指针指向的内存后，将指针设置为`nullptr`，以避免野指针问题。
####  1.1.3. <a name='STL'></a>使用STL库

- **内存管理**：STL容器自动管理它们所包含元素的内存。这意味着当你向容器中添加元素时，容器会负责分配内存来存储这些元素，而当元素不再需要时，容器也会负责释放内存。
- **拷贝和移动语义**：STL容器支持拷贝和移动语义，这意味着容器可以被拷贝或移动，而不是它们的元素被拷贝或移动。这可以提高效率，特别是在处理大型容器时。在你的类中使用STL容器时，你也应该支持拷贝和移动语义。
###  1.2. <a name='-1'></a>自定义类型

类可以包含自定义类型，这些类型可以是其他类、结构体（struct）、枚举（enum）或者是类型别名（using 或 typedef）。使用自定义类型可以让代码更加模块化、可重用和易于维护。
####  1.2.1. <a name='-1'></a>其他类

- **成员对象**：一个类可以拥有另一个类的实例作为其成员，这称为成员对象。
- **聚合**：如果一个类的对象被另一个类的对象所拥有，这种关系称为聚合。聚合是一种特殊的关联，表示整体与部分的关系。
- **组合**：组合是一种比聚合更强的关联，表示类的对象完全拥有另一个类的对象。组合对象的生命周期通常由组合它的类管理。
####  1.2.2. <a name='-1'></a>结构体、枚举、类型别名

TODO
###  1.3. <a name='-1'></a>初始化

- 直接初始化：在成员变量声明时直接进行初始化
- 构造函数成员初始化列表：对于大多数类类型成员变量，推荐使用构造函数的成员初始化列表来进行初始化。直接在创建对象时初始化成员变量，而不是在构造函数体内赋值。
- 构造函数内初始化：在构造函数中赋值，不推荐。
- 默认成员变量：如果你没有为成员变量提供初始值，它们将被默认初始化。对于基本数据类型，这意味着它们将包含垃圾值（对于内置的POD类型，如int、double等）。对于类类型，将调用默认构造函数（如果存在）。
- 列表初始化：C++11
###  1.4. <a name='const'></a>const成员变量

在声明`const`成员变量时，通常需要在类的构造函数初始化列表中或声明时进行初始化，因为`const`变量一旦初始化后就不能在类的成员函数中被修改。如果尝试修改`const`成员变量，会导致编译错误。`const`成员变量的值在对象的生命周期内保持不变。
###  1.5. <a name='static'></a>static成员变量

`static`成员变量在类的内部进行定义和声明时，需要使用`static`关键字进行修饰。在类的外部需要对`static`成员变量进行初始化。

```c++
class MyClass
{
private:
	static int x;
};
int MyClass::x = 10;
```

 `static`成员变量被存储在类的静态存储区，而不是每个对象的内存空间中。这意味着无论创建多少个类的对象，`static`成员变量只有一份副本。所有的对象都共享同一个`static`成员变量。

 `static`成员变量可以在没有创建类的对象的情况下被访问。可以通过类名直接访问`static`成员变量，而不需要通过对象来访问。

  `static`成员变量的生命周期与整个程序的运行周期相同。它在程序开始执行时被创建，在程序结束时被销毁。
##  2. <a name='-1'></a>成员函数

成员函数是类中定义的函数，定义了类的行为。
###  2.1. <a name='-1'></a>基本成员函数

成员函数可以访问类的成员变量和其它成员函数，包括私有和保护的成员。成员函数可以是普通函数，也可以是特殊的成员函数，如构造函数和析构函数。
###  2.2. <a name='const-1'></a>const成员函数

`const`成员函数表明该函数不会修改它所属对象的任何成员变量。`const`成员函数可以访问对象的所有成员变量和其他`const`成员函数，但不能调用非`const`成员函数。

`const`成员函数保证不会改变对象的任何成员变量的值，除非这些成员变量本身被声明为`mutable`（TODO）。

`const`成员函数可以在常量对象上被调用。这意味着如果你有一个常量对象，你只能调用它的`const`成员函数。

`const`成员函数可以返回对象的常量引用，这样可以避免返回值被修改。
TODO：const_cast
###  2.3. <a name='static-1'></a>static成员函数

static成员函数不依赖于类的具体对象实例。静态成员函数不能访问类的非静态成员变量，因为这些变量是与特定对象实例相关的。静态成员函数只能访问类的静态成员变量和其他静态成员函数。
静态成员函数可以通过类名直接调用，也可以通过对象实例调用。通常推荐使用类名调用，以强调其静态性质。
####  2.3.1. <a name='-1'></a>成员函数重载

成员函数重载是通过在同一个类中定义多个具有相同名称的成员函数来实现的，但这些函数的参数列表必须不同。参数列表不同可以是参数的数量、类型或顺序不同。成员函数重载的主要目的是提供多态性（静态多态性），使得同一个函数名可以用于不同的操作。这使得代码更加清晰和易于维护。
##  3. <a name='this'></a>this

`this`是一个特殊的指针，它在每个非静态成员函数中都有定义。`this`指向调用成员函数的对象的地址。使用`this`指针可以访问对象的成员变量和成员函数。
###  3.1. <a name='this-1'></a>this用法

1. **区分成员变量和局部变量**：当成员函数中有一个与成员变量同名的局部变量时，可以使用`this`指针来明确指出你想要访问的是成员变量。
2. **返回对象本身**：在成员函数中，如果你想返回对象本身，可以使用`this`指针。
3. **链式调用**：`this`指针可以用于实现链式调用，即一个函数返回对象的引用，然后可以立即调用另一个函数。
4. **在成员函数中使用`this`**： 在成员函数中，你可以直接使用`this`，而不需要任何前缀。
5. **在静态成员函数中**： 静态成员函数不能访问`this`指针，因为静态成员函数不与任何特定的对象实例关联。
##  4. <a name='Scope'></a>类作用域(Scope)

类的作用域是指类成员（包括数据成员和成员函数）的可见性和访问权限。类的作用域规则决定了在类的外部或内部哪些成员是可以访问的。

- **类外访问类的成员**，可以使用作用域解析运算符`::`。
- **成员函数中的作用域**： 在成员函数内部，你可以访问类的其他成员，包括其他成员函数和数据成员。成员函数可以调用其他成员函数，也可以访问类的实例变量。

**成员访问权限**： C++中的类成员可以有三种访问权限：`public`、`protected`和`private`。
- `public`：类的公共成员可以在类的外部被访问。
- `protected`：受保护的成员只能在类的内部以及继承自该类的子类中被访问。
- `private`：私有成员只能在类的内部被访问。
##  5. <a name='Friend'></a>友元（Friend）

友元是一种特殊的机制，它允许一个非成员函数或者一个类的成员函数访问另一个类的私有（private）和受保护（protected）成员。友元机制打破了类的封装性，使得某些特定的函数可以访问类的内部数据，这在某些情况下是非常有用的，比如实现某些操作符重载、辅助函数或者与其他类进行紧密协作时。

友元是一种强大的机制，但它也破坏了类的封装性，因此在使用时需要谨慎。过度使用友元可能会导致代码难以维护和理解，因为它模糊了类之间的界限。在设计类时，应该尽可能地使用公共接口来实现所需的功能，只在必要时使用友元。
###  5.1. <a name='-1'></a>友元函数

友元函数是一个非成员函数，它可以访问类的私有和受保护成员。
###  5.2. <a name='-1'></a>友元类

友元类是指一个类可以声明另一个类为其友元，这样另一个类的所有成员函数都可以访问该类的私有和受保护成员。
###  5.3. <a name='-1'></a>注意事项

1. **友元是单向的**：如果类A是类B的友元，并不意味着类B自动成为类A的友元。如果需要双向访问，两个类必须相互声明对方为友元。
2. **友元不继承**：友元关系不具有继承性。如果类B是类A的友元，类C继承自类A，并不意味着类C自动成为类B的友元。
3. **友元与封装**：虽然友元可以访问类的私有和受保护成员，但它们并不是类的成员，因此不能直接访问类的保护成员，除非这些保护成员也是公有的。
4. **友元与多态**：友元函数不能访问类的虚函数表，因此它们不能利用多态性。
##  6. <a name='-1'></a>类类型

# 面向对象程序设计(OOP)

概念：面向对象编程（Object-Oriented Programming，OOP）是一种编程范式，它将现实世界中的实体抽象为对象，并通过这些对象之间的交互来设计和构建软件系统。

核心思想：**数据抽象**、**继承**和**动态绑定**
> 数据抽象：可以将类的接口与实现分离；
> 继承：可以定义相似的类型并对其相似关系建模;
> 动态绑定：可以在一定程度上忽略相似类型的区别,而以统一的方式使用它们的对象。 

例：教务管理系统
TODO：介绍例子
学生类，教师类，管理员类。
##  7. <a name='-1'></a>继承与动态绑定
###  7.1. <a name='-1'></a>基类

基类（也称为父类或超类）是用于被其他类继承的类。

> 在基类中用`virtual`关键字声明的成员函数称为**虚函数**。
> 
> 被声明为`protected`(受保护的)的成员可以被该类的**成员函数**、**派生类的成员函数**和**友元函数**访问，但**不能被类的外部代码直接访问**。
###  7.2. <a name='-1'></a>派生类
派生类（也称为子类）是从一个或多个基类（父类）继承而来的类。

> `:`后面是**派生类列表**，用于指定一个类从哪些基类继承而来。大多数只继承自一个类，这种形式称为单继承。（多继承将在后续介绍）
> 
> `override`关键字用于明确标识一个派生类中的函数是对基类中虚函数的重写。派生类经常(但不总是)覆盖继承的虚函数。派生类可以在它继承的函数前使用virtual关键字(可以省略)。
>  
>  如果派生类没有覆盖基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。

#### 派生类对象及派生类向基类的类型转换
#### 派生类的构造函数
#### 派生类使用基类的成员
#### 派生类的声明
#### 被用作为基类的类
#### 防止继承发生
#### 纯虚函数
###  7.3. <a name='-1'></a>动态绑定
###  7.4. <a name='-1'></a>虚函数
###  7.5. <a name='-1'></a>继承与静态成员
###  7.6. <a name='-1'></a>继承与类型转换
###  7.7. <a name='-1'></a>继承与控制访问
###  7.8. <a name='-1'></a>继承与类作用域
###  7.9. <a name='-1'></a>继承与友元
##  8. <a name='-1'></a>拷贝控制

###  8.1. <a name='-1'></a>构造

###  8.2. <a name='-1'></a>拷贝

###  8.3. <a name='-1'></a>赋值

###  8.4. <a name='-1'></a>析构

###  8.5. <a name='-1'></a>移动
##  9. <a name='-1'></a>重载运算

###  9.1. <a name='-1'></a>基本概念
#### 概念：

运算符重载（Operator Overloading）是一种允许程序员为自定义类型（如类和结构体）定义或改变已有运算符（如+、-、*、/等）行为的功能。
#### 目的：

1. 增强代码的可读性和直观性：通过使用熟悉的运算符，可以使代码更接近自然语言的表达，例如对自定义的矩阵类重载 “+” 运算符来实现矩阵相加，代码看起来更加直观。
2. 方便操作自定义类型：使得对自定义类型的操作与内置类型的操作方式类似，提高了代码的一致性和易用性。
#### 可重载的运算符

1. 算术运算符：`+`、`-`、`*`、`/`、`%`、`++`、`--`。
2. 关系运算符：`==`、`!=`、`<`、`>`、`<=`、`>=`。
3. 逻辑运算符：`!`、`&&`、`||`、`!`(不推荐重载，因为它是一个单目运算符，并且通常用作逻辑运算。
4. 赋值运算符：`=`、`+=`、`-=`、`*=`、`/=`、`%=`、`^=`、`&=`、`|=`、`<<=`、`>>=`。
6. 输入输出运算符：`<<`和 `>>`。
7. 位运算符：`^`、`&`、`|`、`~`。
8. 下标：`[]`。
9. 函数调用：`()`。
10. 访问运算符：`->`、`->*`。
11. `new`、`new[]`、`delete`、`delete[]`。
#### 不可重载的运算符

1. 访问运算符：`.`、`.*`。
2. 作用域解析运算符：`::`。
3. 条件运算符：`?:`(三元运算符)。
4. `sizeof`运算符。
5. `typeid`运算符。
###  9.2. <a name='-1'></a>重载运算例

#### 重载输出运算符`<<`和输入运算符`>>`

输入输出运算符必须是非成员函数。

```c++
ostream &operator<<(ostream& os, const Course& c)
{
	os << c.uid() << " " << c.name() << " " << c.classroom(); 
	return os;
}
```

> 第一个形参：是一个非常量ostream对象的引用。因为向流写入内容会改变其状态，形参是引用是因为无法直接复制一个otream对象。
> 第二个形参：一般是一个常量的引用。是操作的对象。

```C++
istream &operator>>(istream& is, Course& c)
{

}
```
> 第一个形参：是将要读取的流的引用。
> 第二个形参：是将要读入到对象中的引用。

**错误处理**：
#### 算术和关系运算符

```C++
Complex operator+(const Complex& c1, const Complex& c2)
{
	Complex sum;
	sum.r = c1.r + c2.r;
	sum.i = c1.i + c2.i;
	return sum;
}
```

#### 相等运算符

#### 关系运算符

#### 赋值运算符

#### 下标运算符

#### 递增和递减运算符

#### 成员访问运算符

### 函数调用运算符

#### lambda表达式

#### 函数对象

#### 可调用对象与function

