* 1. [基本内置类型](#基本内置类型)
	* 1.1. [算术类型](#算术类型)
		* 1.1.1. [算术类型](#算术类型)
		* 1.1.2. [算术类型的尺寸](#算术类型的尺寸)
		* 1.1.3. [符号](#符号)
	* 1.2. [如何选择类型](#如何选择类型)
	* 1.3. [类型转换](#类型转换)
	* 1.4. [字面值常量](#字面值常量)
* 2. [变量](#变量)
	* 2.1. [定义](#定义)
		* 2.1.1. [基本形式](#基本形式)
		* 2.1.2. [初始值](#初始值)
		* 2.1.3. [声明和定义的关系](#声明和定义的关系)
	* 2.2. [标识符](#标识符)
		* 2.2.1. [命名规范](#命名规范)
		* 2.2.2. [标志符的作用域](#标志符的作用域)
* 3. [复合类型](#复合类型)
	* 3.1. [引用](#引用)
	* 3.2. [指针](#指针)
	* 3.3. [复合复合类型](#复合复合类型)
* 4. [const限定符](#const限定符)
* 5. [处理类型](#处理类型)
	* 5.1. [类型别名](#类型别名)
	* 5.2. [auto类型说明符](#auto)
	* 5.3. [decltype类型指示符](#decltype)
* 6. [自定义数据结构](#自定义数据结构)
	* 6.1. [定义结构体](#定义结构体)
	* 6.2. [使用结构体](#使用结构体)
* 7. [多文件](#多文件)

# 变量

数据类型是程序的基础：它告诉我们数据的意义以及能在数据上执行的操作。
##  1. <a name='基本内置类型'>基本内置类型</a>

基本内置类型包括了算术类型和空类型。
###  1.1. <a name='算术类型'>算术类型</a>

算术类型分为两类：整型和浮点型。
####  1.1.1. <a name='算术类型'>算术类型</a>

| 类型            | 含义               | 最小尺寸（字节） | 能够表示的范围                              |
| ------------- | ---------------- | -------- | ------------------------------------ |
| `char`        | 字符类型             | 1        | -128 到 127（有符号）或 0 到 255（无符号）        |
| `wchar_t`     | 宽字符类型            | 2或4      | 依赖于实现，通常至少能表示所有Unicode字符             |
| `char16_t`    | 用于存储16位Unicode字符 | 2        | 0 到 65535（U+0000 到 U+FFFF）           |
| `char32_t`    | 用于存储32位Unicode字符 | 4        | 0 到 4294967295（U+0000 到 U+10FFFF）    |
| `int`         | 整数类型             | 2        | -2^31 到 2^31-1（有符号）或 0 到 2^32-1（无符号） |
| `short`       | 短整型              | 2        | -2^15 到 2^15-1（有符号）或 0 到 2^16-1（无符号） |
| `long`        | 长整型              | 4        | -2^31 到 2^31-1（有符号）或 0 到 2^32-1（无符号） |
| `long long`   | 超长整型             | 8        | -2^63 到 2^63-1（有符号）或 0 到 2^64-1（无符号） |
| `float`       | 单精度浮点数           | 4        | 约 1.2E-38 到 3.4E38                   |
| `double`      | 双精度浮点数           | 8        | 约 2.3E-308 到 1.8E308                 |
| `long double` | 扩展精度浮点数          | 8或更大     | 通常比`double`更精确                       |
| `bool`        | 布尔类型             | 1        | true 或 false                         |
- 整型：`int `，`short`， `long`， `long long`，字符型，`bool`。
- 浮点型：`float`，`double`，`long double`。
- 字符类型：char确保可以存放机器基本字符集中任意字符对应的数字值，char的大小和一个机器字节是一样的。其他字符类型用于扩展字符集。
####  1.1.2. <a name='算术类型的尺寸'>算术类型的尺寸</a>

算数类型的尺寸：该类型数据所占的比特数。
- 算数类型的尺寸不同电脑上有所差异。
- C++标准仅规定了不同尺寸的最小值，允许编译器赋予这些类型更大的尺寸。（大多都比规定的大）
- 所占的比特数不同，所能表示的数据范围也不一样。
- 尺寸可以用`sizeof()`编译时运算符获取。
####  1.1.3. <a name='符号'>符号</a>

除了布尔型和拓展的字符型之外，其他整型都可以划分为带符号和无符号的。在类型名前添加unsigned就可以得到无符号类型。值得注意的是：char类型只会表现为无符号和有符号中的一种，由编译器决定。

###  1.2. <a name='如何选择类型'>如何选择类型</a>

- **当明确知晓数值不可能为负时，选用无符号类型**。
- **使用整型时常使用int。如果你的数值超过了int的表示范围,选用long long**。
- **在算术表达式中不要使用char或bool**。因为类型char在一些机器上是有符号的,而在另一些机器上又是无符号的。
- **执行浮点数运算选用 double**，这是因为 float 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说,双精度运算甚至比单精度还快。long double 提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。
###  1.3. <a name='类型转换'>类型转换</a>

类型转换：将对象从一种给定的类型转换为另一种相关类型。

隐式类型转换：

- 把一个非布尔类型的算术值赋给布尔类型时，初始值为`0`则结果为`false`，否则结果为`true`。
- 把一个布尔值赋给非布尔类型时，初始值为false则结果为`0`，初始值为`true`则结果为`1`。
- 把一个浮点数赋给整数类型时，结果值将仅保留浮点数中小数点之前的部分。
- 把一个整数值赋给浮点类型时，小数部分记为`0`。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。
- 给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。
- 当我们赋给带符号类型一个超出它表示范围的值时，结果是**未定义的(undefined)**。程序可能继续工作、可能崩溃，也可能生成垃圾数据。

显示类型转换：

TODO

###  1.4. <a name='字面值常量'>字面值常量</a>

每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

- 整数型：以`0`开头的整数代表八进制数,以`0x`或`0X`开头的代表十六进制数。
- 浮点数型：用一个小数或以科学计数法表示的指数，其中指数部分用`E`或`e`标识。
- 转义序列：一类是不可打印的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符(单引号、双引号、问号、反斜线)。转义序列均以反斜线作为开始。
- ![[Pasted image 20241110135920.png]]
- 指定字面值的类型：添加前缀和后缀可以改变字面值的默认类型。
- ![[Pasted image 20241110140014.png]]
- 布尔字面值：`true`，`false`。
- 指针字面值：`nullptr`。

##  2. <a name='变量'>变量</a>

变量提供一个**具名的**、**可供程序操作的存储空间**。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。

对C++程序员来说, "变量(variable)”和“对象(object)”一般可以互换使用。

###  2.1. <a name='定义'>定义</a>

####  2.1.1. <a name='基本形式'>基本形式</a>

变量定义的基本形式是：首先是类型说明符，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔,最后以分号结束。列表中每个变量名的类型都由类型说明符指定，定义时还可以为一个或多个变量赋初值。

####  2.1.2. <a name='初始值'>初始值</a>

**初始化**：对象在创建时获得一个**特定**的值。

**初始化不是赋值**，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

**列表初始化(C++11)**
TODO
当用于内置类型的变量时。这种初始化形式有一个重要特点。如果我们使用列表初始化且初始值存在丢失信息的风险,则编译器将报错。

**默认初始化**

如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。定义在`main`函数中的默认初始化为垃圾数据，定义在`main`外的初始化为0。

如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是**未定义的**，如果试图拷贝或以其他形式访问此类值将引发错误。

####  2.1.3. <a name='声明和定义的关系'>声明和定义的关系</a>

为了支持分离式编译，C++语言将声明和定义区分开来。声明使得名字为程序所知,一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义负责创建与名字关联的实体。

变量声明规定了变量的类型和名字，定义还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`，而且不要显式地初始化变量
###  2.2. <a name='标识符'>标识符</a>

C++的标识符由字母、数字和下画线组成，其中必须以字母或下画线开头。标识符的长度没有限制,但是对大小写字母敏感。

C++语言保留了一些名字供语言本身使用，这些名字不能被用作标识符。C++也为标准库保留了一些名字。自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。定义在函数体外的标识符不能以下画线开头。

####  2.2.1. <a name='命名规范'>命名规范</a>
####  2.2.2. <a name='标志符的作用域-1'>标志符的作用域</a>

##  3. <a name='复合类型'>复合类型</a>

###  3.1. <a name='引用'>引用</a>

###  3.2. <a name='指针'>指针</a>

###  3.3. <a name='复合复合类型'>复合复合类型</a>

##  4. <a name='const'>const限定符</a>

##  5. <a name='处理类型'>处理类型</a>

###  5.1. <a name='类型别名'>类型别名</a>

###  5.2. <a name='auto'>auto类型说明符</a>

###  5.3. <a name='decltype'>decltype类型指示符</a>

##  6. <a name='自定义数据结构'>自定义数据结构</a>

###  6.1. <a name='定义结构体'>定义结构体</a>

###  6.2. <a name='使用结构体'>使用结构体</a>

##  7. <a name='多文件'>多文件</a>
